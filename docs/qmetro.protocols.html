

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>qmetro.protocols package &mdash; QMetro++ 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=8d563738"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="qmetro.qmtensor package" href="qmetro.qmtensor.html" />
    <link rel="prev" title="qmetro.param_channel package" href="qmetro.param_channel.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            QMetro++
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="qmetro.html">Documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="qmetro.html#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="qmetro.bounds.html">qmetro.bounds package</a></li>
<li class="toctree-l3"><a class="reference internal" href="qmetro.iss_opt.html">qmetro.iss_opt package</a></li>
<li class="toctree-l3"><a class="reference internal" href="qmetro.param_channel.html">qmetro.param_channel package</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">qmetro.protocols package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qmetro.protocols.errors">qmetro.protocols.errors module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qmetro.protocols.iss">qmetro.protocols.iss module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qmetro.protocols.mop">qmetro.protocols.mop module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qmetro.protocols.other">qmetro.protocols.other module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qmetro.protocols.warnings">qmetro.protocols.warnings module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qmetro.protocols">Module contents</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="qmetro.qmtensor.html">qmetro.qmtensor package</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="qmetro.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="qmetro.html#module-qmetro.consts">qmetro.consts module</a></li>
<li class="toctree-l2"><a class="reference internal" href="qmetro.html#module-qmetro.qtools">qmetro.qtools module</a></li>
<li class="toctree-l2"><a class="reference internal" href="qmetro.html#module-qmetro.utils">qmetro.utils module</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">QMetro++</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="qmetro.html">Documentation</a></li>
      <li class="breadcrumb-item active">qmetro.protocols package</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/qmetro.protocols.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="qmetro-protocols-package">
<h1>qmetro.protocols package<a class="headerlink" href="#qmetro-protocols-package" title="Link to this heading"></a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Link to this heading"></a></h2>
</section>
<section id="module-qmetro.protocols.errors">
<span id="qmetro-protocols-errors-module"></span><h2>qmetro.protocols.errors module<a class="headerlink" href="#module-qmetro.protocols.errors" title="Link to this heading"></a></h2>
<dl class="py exception">
<dt class="sig sig-object py" id="qmetro.protocols.errors.EnvDimsError">
<em class="property"><span class="k"><span class="pre">exception</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qmetro.protocols.errors.</span></span><span class="sig-name descname"><span class="pre">EnvDimsError</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">env_inp_dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">env_out_dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/qmetro/protocols/errors.html#EnvDimsError"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qmetro.protocols.errors.EnvDimsError" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ValueError</span></code></p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="qmetro.protocols.errors.UnitalDimsError">
<em class="property"><span class="k"><span class="pre">exception</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qmetro.protocols.errors.</span></span><span class="sig-name descname"><span class="pre">UnitalDimsError</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inp_dims</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_dims</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/qmetro/protocols/errors.html#UnitalDimsError"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qmetro.protocols.errors.UnitalDimsError" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ValueError</span></code></p>
</dd></dl>

</section>
<section id="module-qmetro.protocols.iss">
<span id="qmetro-protocols-iss-module"></span><h2>qmetro.protocols.iss module<a class="headerlink" href="#module-qmetro.protocols.iss" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="qmetro.protocols.iss.iss_adaptive_qfi">
<span class="sig-prename descclassname"><span class="pre">qmetro.protocols.iss.</span></span><span class="sig-name descname"><span class="pre">iss_adaptive_qfi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">channel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="qmetro.param_channel.html#qmetro.param_channel.param_channel.ParamChannel" title="qmetro.param_channel.param_channel.ParamChannel"><span class="pre">ParamChannel</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_channels</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ancilla_dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">artificial_noise_after</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">env_inp_state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/qmetro/protocols/iss.html#iss_adaptive_qfi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qmetro.protocols.iss.iss_adaptive_qfi" title="Link to this definition"></a></dt>
<dd><p>Computes quantum Fisher information channels in an adaptive control
system called quantum comb using iterative see-saw (ISS) algorithm
<a class="reference internal" href="#r549a9bd2af3f-1" id="id1">[1]</a>.</p>
<p>In this approach we consider n copies of a quantum channel Phi:</p>
<blockquote>
<div><p>Phi_i: L(env_i (x) in_i) -&gt; L(env_i+1 (x) out_i)
for i = 0, …, n - 1,</p>
</div></blockquote>
<p>put in a quantum comb C from a set:</p>
<blockquote>
<div><p>Comb[(Null, in_0), (out_0, in_1), …, (out_n-2, in_n-1 (x) anc)],</p>
</div></blockquote>
<p>and a measurement at the end:</p>
<blockquote>
<div><p>P: L(out_n-1 (x) anc) -&gt; R,</p>
</div></blockquote>
<p>where (x) denotes a tensor product of Hilbert spaces.</p>
<p>The input of the first environment space (env_0) is initialized with
<cite>env_inp_state</cite> and the last environment spcace (env_n) is traced out.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>channel</strong> (<a class="reference internal" href="qmetro.param_channel.html#qmetro.param_channel.param_channel.ParamChannel" title="qmetro.param_channel.param_channel.ParamChannel"><em>ParamChannel</em></a>) – Channel to compute quantum Fisher information for. In case this
argument is a comb created from single channels the control
operation (comb’s tooth) will be put between every <strong>single</strong>
channel.</p></li>
<li><p><strong>number_of_channels</strong> (<em>int</em>) – Number of channel uses. In case <cite>channel</cite> is a comb created from
<cite>m</cite> single channels the total number of channels will be equal to
<cite>number_of_channels * m</cite>.</p></li>
<li><p><strong>ancilla_dim</strong> (<em>int</em>) – Dimension of the ancilla space connecting controls (teeth),
dim(anc).</p></li>
<li><p><strong>artificial_noise_after</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether auxiliary noise is added after the channel:
- True : auxiliary noise is added after the channel,
- False : auxiliary noise is added before the channel,
- None : auxiliary noise is not used.
By default True.</p></li>
<li><p><strong>env_inp_state</strong> (<em>np.ndarray</em><em> | </em><em>None</em><em>, </em><em>optional</em>) – Density matrix of the initial state of the environment. If None
then it becomes a maximally mixed state.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>qfi</strong> (<em>float</em>) – Quantum Fisher information.</p></li>
<li><p><strong>qfis</strong> (<em>list[floats]</em>) – A list of quantum Fisher informations acvhieved in each iteration.
The last value in the list is the final solution.</p></li>
<li><p><strong>comb</strong> (<em>np.ndarray</em>) – Choi matrix of the optimal comb with spaces in order: inp_0, …,
inp_n-1, anc, out_0, …, out_n-2.</p></li>
<li><p><strong>L</strong> (<em>np.ndarray</em>) – Optimal syymetric logaritmic derivative (SLD) matrix with spaces
in order: out_n-1, anc.</p></li>
<li><p><strong>status</strong> (<em>bool</em>) – True if the algorithm converged, False otherwise.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r549a9bd2af3f-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>S. Kurdziałek et al. Quantum metrology using quantum combs and
tensor network formalism, New Journal of Physics (2024).
<a class="reference external" href="https://doi.org/10.1088/1367-2630/ada8d1">https://doi.org/10.1088/1367-2630/ada8d1</a></p>
</div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qmetro.protocols.iss.iss_channel_qfi">
<span class="sig-prename descclassname"><span class="pre">qmetro.protocols.iss.</span></span><span class="sig-name descname"><span class="pre">iss_channel_qfi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">channel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="qmetro.param_channel.html#qmetro.param_channel.param_channel.ParamChannel" title="qmetro.param_channel.param_channel.ParamChannel"><span class="pre">ParamChannel</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">ancilla_dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">env_inp_state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">artificial_noise_after</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/qmetro/protocols/iss.html#iss_channel_qfi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qmetro.protocols.iss.iss_channel_qfi" title="Link to this definition"></a></dt>
<dd><p>Computes quantum Fisher information for a single parametrized channel
using iterative see-saw (ISS) method <a class="reference internal" href="#r93d06ae05252-1" id="id2">[1]</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>channel</strong> (<a class="reference internal" href="qmetro.param_channel.html#qmetro.param_channel.param_channel.ParamChannel" title="qmetro.param_channel.param_channel.ParamChannel"><em>ParamChannel</em></a>) – Channel to compute quantum Fisher information for. In case this
argument is a comb created from single channels the whole comb
will be treated as a single channel.</p></li>
<li><p><strong>ancilla_dim</strong> (<em>int</em><em>, </em><em>optional</em>) – Dimension of the ancilla, by default 1.</p></li>
<li><p><strong>env_inp_state</strong> (<em>np.ndarray</em><em> | </em><em>None</em><em>, </em><em>optional</em>) – Density matrix of the initial state of the environment. If None
then it becomes a maximally mixed state.</p></li>
<li><p><strong>artificial_noise_after</strong> (<em>bool</em><em> | </em><em>None</em><em>, </em><em>optional</em>) – Whether auxiliary noise is added after the channel:
- True : auxiliary noise is added after the channel,
- False : auxiliary noise is added before the channel,
- None : auxiliary noise is not used.
By default True.</p></li>
<li><p><strong>kwargs</strong> – Additional arguments passed on to <cite>iss</cite> optimization function.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>qfi</strong> (<em>float</em>) – Quantum Fisher information.</p></li>
<li><p><strong>qfis</strong> (<em>list[float]</em>) – QFI per algorithm iteration number.</p></li>
<li><p><strong>input_state</strong> (<em>np.ndarray</em>) – Density matrix of the optimal input state. The input space of
the channel goes first and the ancilla second.</p></li>
<li><p><strong>sld</strong> (<em>np.ndarray</em>) – Symmetric loagarithmic derivative. The output space of
the channel goes first and the ancilla second.</p></li>
<li><p><strong>status</strong> (<em>bool</em>) – True if the algorithm converged, False otherwise.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r93d06ae05252-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">1</a><span class="fn-bracket">]</span></span>
<p>S. Kurdziałek et al. Quantum metrology using quantum combs and
tensor network formalism, New Journal of Physics (2024).
<a class="reference external" href="https://doi.org/10.1088/1367-2630/ada8d1">https://doi.org/10.1088/1367-2630/ada8d1</a></p>
</div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qmetro.protocols.iss.iss_parallel_qfi">
<span class="sig-prename descclassname"><span class="pre">qmetro.protocols.iss.</span></span><span class="sig-name descname"><span class="pre">iss_parallel_qfi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">channel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="qmetro.param_channel.html#qmetro.param_channel.param_channel.ParamChannel" title="qmetro.param_channel.param_channel.ParamChannel"><span class="pre">ParamChannel</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_channels</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ancilla_dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">artificial_noise_after</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">env_inp_state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/qmetro/protocols/iss.html#iss_parallel_qfi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qmetro.protocols.iss.iss_parallel_qfi" title="Link to this definition"></a></dt>
<dd><p>Computes quantum Fisher information for channels in parallel using
iterative see-saw (ISS) algorithm <a class="reference internal" href="#r7f201bcacb83-1" id="id3">[1]</a>.</p>
<p>In parallel strategy all channels are simultaneously probed by an
entangled input state and their output is collectively measured.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>channel</strong> (<a class="reference internal" href="qmetro.param_channel.html#qmetro.param_channel.param_channel.ParamChannel" title="qmetro.param_channel.param_channel.ParamChannel"><em>ParamChannel</em></a>) – Channel to compute quantum Fisher information for.</p></li>
<li><p><strong>number_of_channels</strong> (<em>int</em>) – Number of channel uses. In case <cite>channel</cite> is a comb created from
<cite>m</cite> single channels the total number of channels will be equal to
<cite>number_of_channels * m</cite>.</p></li>
<li><p><strong>ancilla_dim</strong> (<em>int</em>) – Dimension of the ancilla space.</p></li>
<li><p><strong>artificial_noise_after</strong> (<em>bool</em><em> | </em><em>None</em><em>, </em><em>optional</em>) – Whether auxiliary noise is added after the channel:
- True : auxiliary noise is added after the channel,
- False : auxiliary noise is added before the channel,
- None : auxiliary noise is not used.
By default None.</p></li>
<li><p><strong>env_inp_state</strong> (<em>np.ndarray</em><em> | </em><em>None</em><em>, </em><em>optional</em>) – Density matrix of the initial state of the environment. If None
then it becomes a maximally mixed state.</p></li>
<li><p><strong>kwargs</strong> – Additional arguments passed on to <cite>iss</cite> optimization function.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>qfi</strong> (<em>float</em>) – Qunatum Fisher information.</p></li>
<li><p><strong>qfis</strong> (<em>list[float]</em>) – QFI per algorithm iteration number.</p></li>
<li><p><strong>input_state</strong> (<em>np.ndarray</em>) – Density matrix of the optimal input state. The input spaces of
the channels go first and the ancilla goes last.</p></li>
<li><p><strong>sld</strong> (<em>np.ndarray</em>) – Symmetric loagarithmic derivative. The output spaces of
the channels go first and the ancilla goes last.</p></li>
<li><p><strong>status</strong> (<em>bool</em>) – True if the algorithm converged, False otherwise.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r7f201bcacb83-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">1</a><span class="fn-bracket">]</span></span>
<p>K. Chabuda et al. Tensor-Network Approach for Quantum Metrology
in Many-Body Quantum Systems, Nature Commun 11, 250 (2020).
<a class="reference external" href="https://doi.org/10.1038/s41467-019-13735-9">https://doi.org/10.1038/s41467-019-13735-9</a></p>
</div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qmetro.protocols.iss.iss_tnet_adaptive_qfi">
<span class="sig-prename descclassname"><span class="pre">qmetro.protocols.iss.</span></span><span class="sig-name descname"><span class="pre">iss_tnet_adaptive_qfi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">channel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="qmetro.param_channel.html#qmetro.param_channel.param_channel.ParamChannel" title="qmetro.param_channel.param_channel.ParamChannel"><span class="pre">ParamChannel</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_channels</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ancilla_dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unital_teeth</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_teeth</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_sld</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">artificial_noise_after</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed_teeth</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">env_inp_state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/qmetro/protocols/iss.html#iss_tnet_adaptive_qfi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qmetro.protocols.iss.iss_tnet_adaptive_qfi" title="Link to this definition"></a></dt>
<dd><p>Computes quantum Fisher information in an adaptive control
system called quantum comb using iterative see-saw (ISS) algorithm
<a class="reference internal" href="#rb56586dbdeec-1" id="id4">[1]</a>.</p>
<p>In this approach we consider n copies of a quantum channel Phi:</p>
<blockquote>
<div><p>Phi_i: L(env_i (x) in_i) -&gt; L(env_i+1 (x) out_i)
for i = 0, …, n - 1,</p>
</div></blockquote>
<p>intertwined with n maps called teeth:
- input state (or 0-th tooth):</p>
<blockquote>
<div><p>T_0: C -&gt; L(in_0 (x) anc_0),</p>
</div></blockquote>
<ul>
<li><p>(proper) teeth:</p>
<blockquote>
<div><p>T_i: L(out_i-1 (x) anc_i-1) -&gt; L(in_i (x) anc_i)
for i = 1, …, n - 1,</p>
</div></blockquote>
</li>
</ul>
<p>which constitute an adaptive control system called quantum comb and a
measurement at the end:</p>
<blockquote>
<div><p>P: L(out_n-1 (x) anc_n-1) -&gt; R.</p>
</div></blockquote>
<p>The input of the first environment space (env_0) is initialized with
<cite>env_inp_state</cite> and the last environment spcace (env_n) is traced out.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>channel</strong> (<a class="reference internal" href="qmetro.param_channel.html#qmetro.param_channel.param_channel.ParamChannel" title="qmetro.param_channel.param_channel.ParamChannel"><em>ParamChannel</em></a>) – Channel to compute quantum Fisher information for. In case this
argument is a comb created from single channels the control
operation (tooth) will be put between every <strong>single</strong> channel.</p></li>
<li><p><strong>number_of_channels</strong> (<em>int</em>) – Number of channel uses. In case <cite>channel</cite> is a comb created from
<cite>m</cite> single channels the total number of channels will be equal to
<cite>number_of_channels * m</cite>.</p></li>
<li><p><strong>ancilla_dim</strong> (<em>int</em>) – Dimension of the ancilla space connecting controls (teeth),
dim(anc_i).</p></li>
<li><p><strong>unital_teeth</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True than all proper teeth (T_i with i&gt;0) are constrained to be
unital, that is they preserve identity matrix T_i(Id) = Id, by
default False.</p></li>
<li><p><strong>initial_teeth</strong> (<em>list</em><em>[</em><em>np.ndarray</em><em>] </em><em>| </em><em>None</em><em>, </em><em>optional</em>) – Initial values of teeth: [T_0, T_1, …]. First element that is
the value for the input state should be its density matrix with
spaces in the order: (inp_0, anc_0). For proper teeth it should be
Choi matrices with spaces in the order: (inp_i, anc_i, out_i-1,
anc_i-1), by default None.</p></li>
<li><p><strong>initial_sld</strong> (<em>np.ndarray</em><em> | </em><em>None</em><em>, </em><em>optional</em>) – Initial value of SLD matrix with spaces in order (out_n-1,
anc_n-1), by default None.</p></li>
<li><p><strong>artificial_noise_after</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether auxiliary noise is added after the channel:
- True : auxiliary noise is added after the channel,
- False : auxiliary noise is added before the channel,
- None : auxiliary noise is not used.
By default True.</p></li>
<li><p><strong>fixed_teeth</strong> (<em>list</em><em>[</em><em>tuple</em><em>[</em><em>int</em><em>, </em><em>np.ndarray</em><em>]</em><em>] </em><em>| </em><em>None</em><em>, </em><em>optional</em>) – Teeths to be fixed during optimization. Element (i, Ti) in the
list means that tooth number i will be fixed to Ti. Note that this
value will replace the value given in initial_teeth argument, by
default None.</p></li>
<li><p><strong>env_inp_state</strong> (<em>np.ndarray</em><em> | </em><em>None</em><em>, </em><em>optional</em>) – Density matrix of the initial state of the environment. If None
then it becomes a maximally mixed state.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>qfi</strong> (<em>float</em>) – Quantum Fisher information.</p></li>
<li><p><strong>qfis</strong> (<em>list[floats]</em>) – A list of quantum Fisher informations acvhieved in each iteration.
The last value in the list is the final solution.</p></li>
<li><p><strong>Ts</strong> (<em>list[np.ndarray]</em>) – List of optimal teeth in the form of density matrix and Choi
matrices. For the i-th element - T_i spaces are in order:
- (inp_0, anc_0) for i=0,
- (inp_i, anc_i, out_i-1, anc_i-1) for i&gt;0.</p></li>
<li><p><strong>L</strong> (<em>np.ndarray</em>) – Optimal syymetric logaritmic derivative (SLD) matrix with spaces
in order: out_n-1, anc.</p></li>
<li><p><strong>status</strong> (<em>bool</em>) – True if the algorithm converged, False otherwise.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rb56586dbdeec-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">1</a><span class="fn-bracket">]</span></span>
<p>S. Kurdziałek et al. Quantum metrology using quantum combs and
tensor network formalism, New Journal of Physics (2024).
<a class="reference external" href="https://doi.org/10.1088/1367-2630/ada8d1">https://doi.org/10.1088/1367-2630/ada8d1</a></p>
</div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qmetro.protocols.iss.iss_tnet_collisional_qfi">
<span class="sig-prename descclassname"><span class="pre">qmetro.protocols.iss.</span></span><span class="sig-name descname"><span class="pre">iss_tnet_collisional_qfi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">channel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="qmetro.param_channel.html#qmetro.param_channel.param_channel.ParamChannel" title="qmetro.param_channel.param_channel.ParamChannel"><span class="pre">ParamChannel</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_channels</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ancilla_dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mps_bond_dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measure_bond_dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unital_teeth</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_teeth</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">artificial_noise_after</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed_teeth</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">env_inp_state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/qmetro/protocols/iss.html#iss_tnet_collisional_qfi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qmetro.protocols.iss.iss_tnet_collisional_qfi" title="Link to this definition"></a></dt>
<dd><p>Returns the quantum Fisher information in a scenario with channels in
a comb which teeth have separate ancillas using iterative see-saw
(ISS) algorithm. This is a very similar structure to the one in the
adaptive strategy the only difference being that comb’s teeth cannot
communicate with each other using their common ancilla space.</p>
<p>More precisely, in this approach we consider n copies of a quantum
channel Phi:</p>
<blockquote>
<div><p>Phi_i: L(env_i (x) in_i) -&gt; L(env_i+1 (x) out_i)
for i = 0, …, n - 1,</p>
</div></blockquote>
<p>an input state:</p>
<blockquote>
<div><p>rho0 in L(in_0 (x) anc_0 (x) … (x) anc_n-2),</p>
</div></blockquote>
<p>controls called also teeth:</p>
<blockquote>
<div><p>T_i: L(out_i-1 (x) anc_i-1) -&gt; L(in_i (x) anc’_i-1)
for i = 1, …, n - 1,</p>
</div></blockquote>
<p>and measurement at the end:</p>
<blockquote>
<div><p>P: L(anc’_0 (x) … (x) anc’_n-2 (x) out_n-1) -&gt; R.</p>
</div></blockquote>
<p>The input of the first environment space (env_0) is initialized with
<cite>env_inp_state</cite> and the last environment spcace (env_n) is traced out.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>channel</strong> (<a class="reference internal" href="qmetro.param_channel.html#qmetro.param_channel.param_channel.ParamChannel" title="qmetro.param_channel.param_channel.ParamChannel"><em>ParamChannel</em></a>) – Channel to compute quantum Fisher information for. In case this
argument is a comb created from single channels the control
operation (comb’s tooth) will be put between every <strong>single</strong>
channel.</p></li>
<li><p><strong>number_of_channels</strong> (<em>int</em>) – Number of channel uses. In case <cite>channel</cite> is a comb created from
<cite>m</cite> single channels the total number of channels will be equal to
<cite>number_of_channels * m</cite>.</p></li>
<li><p><strong>ancilla_dim</strong> (<em>int</em>) – Dimension of the ancilla space connecting controls (teeth).</p></li>
<li><p><strong>mps_bond_dim</strong> (<em>int</em>) – Dimension of the bond space of the input state which is a matrix
product state.</p></li>
<li><p><strong>measure_bond_dim</strong> (<em>int</em>) – Dimension of the bond space of the measurement (SLD matrix) which
is a matrix product operator.</p></li>
<li><p><strong>unital_teeth</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True than all proper teeth (T_i with i&gt;0) are constrained to be
unital, that is they preserve identity matrix T_i(Id) = Id, by
default False.</p></li>
<li><p><strong>initial_teeth</strong> (<em>list</em><em>[</em><em>np.ndarray</em><em>] </em><em>| </em><em>None</em><em>, </em><em>optional</em>) – Initial values of teeth: [T_1, …]. For T_i it should be its
Choi matrix with spaces in the order: (inp_i, anc’_i-1, out_i-1,
anc_i-1), by default None.</p></li>
<li><p><strong>artificial_noise_after</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether auxiliary noise is added after the channel:
- True : auxiliary noise is added after the channel,
- False : auxiliary noise is added before the channel,
- None : auxiliary noise is not used.
By default True.</p></li>
<li><p><strong>fixed_teeth</strong> (<em>list</em><em>[</em><em>tuple</em><em>[</em><em>int</em><em>, </em><em>np.ndarray</em><em>]</em><em>] </em><em>| </em><em>None</em><em>, </em><em>optional</em>) – Teeths to be fixed during optimization. Element (i, Ti) in the
list means that tooth number i will be fixed to Ti. Note that this
value will replace the value given in initial_teeth argument, by
default None.</p></li>
<li><p><strong>env_inp_state</strong> (<em>np.ndarray</em><em> | </em><em>None</em><em>, </em><em>optional</em>) – Density matrix of the initial state of the environment. If None
then it becomes a maximally mixed state.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>qfi</strong> (<em>float</em>) – Quantum Fisher information.</p></li>
<li><p><strong>qfis</strong> (<em>list[floats]</em>) – A list of quantum Fisher informations computed in each iteration.
The last value in the list is the final solution.</p></li>
<li><p><strong>input_state</strong> (<em>list[np.array]</em>) – The optimal matrix product state (MPS). The i-th tensor on the list
- R_i is the input of the i-th channel except the last which is the
part going to ancilla. Its indices are in the order: bond space
connecting to the previous tensor (if it exists), input state of
the channel/ancilla, bond space connecting to the next tensor (if
it exists).</p></li>
<li><p><strong>Ts</strong> (<em>list[np.ndarray]</em>) – List of optimal teeth [T_1, T_2, …] in the form of their Choi
matrices. For the i-th element - T_i spaces are in order (inp_i,
anc’_i-1, out_i-1, anc_i-1).</p></li>
<li><p><strong>sld</strong> (<em>list[np.array]</em>) – Matrix product operator (MPO) of the optimal symmetric logarithmic
derivative (SLD). For i &lt; n-1 i-th tensor on the list is a sld
element on anc’_i then the last tensor on the list is a sld
element on space out_n-1. Indices/spaces of the i-th tnesor are in
the order: bond space connecting to the previous tensor (if it
exists), out_n-1 or anc’_i-1, bond space connecting to the next
tensor (if it exists).</p></li>
<li><p><strong>status</strong> (<em>bool</em>) – True if the algorithm converged, False otherwise.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r20d192ecfbab-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>K. Chabuda et al. Tensor-Network Approach for Quantum Metrology
in Many-Body Quantum Systems, Nature Commun 11, 250 (2020).
<a class="reference external" href="https://doi.org/10.1038/s41467-019-13735-9">https://doi.org/10.1038/s41467-019-13735-9</a></p>
</div>
<div class="citation" id="r20d192ecfbab-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>S. Kurdziałek et al. Quantum metrology using quantum combs and
tensor network formalism, New Journal of Physics (2024).
<a class="reference external" href="https://doi.org/10.1088/1367-2630/ada8d1">https://doi.org/10.1088/1367-2630/ada8d1</a></p>
</div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qmetro.protocols.iss.iss_tnet_parallel_qfi">
<span class="sig-prename descclassname"><span class="pre">qmetro.protocols.iss.</span></span><span class="sig-name descname"><span class="pre">iss_tnet_parallel_qfi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">channel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="qmetro.param_channel.html#qmetro.param_channel.param_channel.ParamChannel" title="qmetro.param_channel.param_channel.ParamChannel"><span class="pre">ParamChannel</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_channels</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ancilla_dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mps_bond_dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measure_bond_dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">artificial_noise_after</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">env_inp_state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/qmetro/protocols/iss.html#iss_tnet_parallel_qfi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qmetro.protocols.iss.iss_tnet_parallel_qfi" title="Link to this definition"></a></dt>
<dd><p>Computes quantum Fisher information for channels in parallel using
iterative see-saw algorithm and tensor networks, that is matrix
product state (MPS) and matrix product operators (MPOs).</p>
<p>In parallel strategy all channels are simultaneously probed by an
entangled input state and their output is collectively measured.</p>
<p>In the approach with tensor networks the input state is expressed as
a tensor network in a shape of a line where i-th tensor represents
part of the input state that goes to the i-th probe channel and
has is connected with two other tensors (one tensor in case of the
first and the last one) with bond spaces/indices <a class="reference internal" href="#r1f4884309a67-1" id="id5">[1]</a>.</p>
<p>The measurement and then the symmetric logarithmic derivative (SLD)
matrix is expressed as an analogous tensor network (representing
operators instead of states) called matrix product operator (MPO).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>channel</strong> (<a class="reference internal" href="qmetro.param_channel.html#qmetro.param_channel.param_channel.ParamChannel" title="qmetro.param_channel.param_channel.ParamChannel"><em>ParamChannel</em></a>) – Channel to compute quantum Fisher information for.</p></li>
<li><p><strong>number_of_channels</strong> (<em>int</em>) – Number of channel uses. In case <cite>channel</cite> is a comb created from
<cite>m</cite> single channels the total number of channels will be equal to
<cite>number_of_channels * m</cite>.</p></li>
<li><p><strong>ancilla_dim</strong> (<em>int</em>) – Dimension of the ancilla space.</p></li>
<li><p><strong>mps_bond_dim</strong> (<em>int</em>) – Dimension of the bond space of the input state which is a matrix
product state (MPS).</p></li>
<li><p><strong>measure_bond_dim</strong> (<em>int</em>) – Dimension of the bond space of the measurement (SLD) which is
a matrix product operator.</p></li>
<li><p><strong>artificial_noise_after</strong> (<em>bool</em><em> | </em><em>None</em><em>, </em><em>optional</em>) – Whether auxiliary noise is added after the channel:
- True : auxiliary noise is added after the channel,
- False : auxiliary noise is added before the channel,
- None : auxiliary noise is not used.
By default None.</p></li>
<li><p><strong>env_inp_state</strong> (<em>np.ndarray</em><em> | </em><em>None</em><em>, </em><em>optional</em>) – Density matrix of the initial state of the environment. If None
then it becomes a maximally mixed state.</p></li>
<li><p><strong>kwargs</strong> – Additional arguments passed on to <cite>iss</cite> optimization function.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>qfi</strong> (<em>float</em>) – Qunatum Fisher information.</p></li>
<li><p><strong>qfis</strong> (<em>list[float]</em>) – QFI per algorithm iteration number.</p></li>
<li><p><strong>input_state</strong> (<em>list[np.array]</em>) – The optimal matrix product state (MPS). The i-th tensor on the list
- R_i is the input of the i-th channel except the last which is the
part going to ancilla. Its indices are in the order: bond space
connecting to the previous tensor (if it exists), input state of
the channel/ancilla, bond space connecting to the next tensor (if
it exists).</p></li>
<li><p><strong>sld</strong> (<em>list[np.array]</em>) – Matrix product operator (MPO) of the optimal symmetric logarithmic
derivative (SLD). The i-th tensor on the list - L_i is sld MPO
elemnt on the output of the i-th channel except the last one which
is on ancilla. Its indices/spaces are in the order: bond space
connecting to the previous tensor (if it exists), channel output
or ancilla, bond space connecting to the next tensor (if it
exists).</p></li>
<li><p><strong>status</strong> (<em>bool</em>) – True if the algorithm converged, False otherwise.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r1f4884309a67-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">1</a><span class="fn-bracket">]</span></span>
<p>K. Chabuda et al. Tensor-Network Approach for Quantum Metrology
in Many-Body Quantum Systems, Nature Commun 11, 250 (2020).
<a class="reference external" href="https://doi.org/10.1038/s41467-019-13735-9">https://doi.org/10.1038/s41467-019-13735-9</a></p>
</div>
</div>
</dd></dl>

</section>
<section id="module-qmetro.protocols.mop">
<span id="qmetro-protocols-mop-module"></span><h2>qmetro.protocols.mop module<a class="headerlink" href="#module-qmetro.protocols.mop" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="qmetro.protocols.mop.mop_adaptive_qfi">
<span class="sig-prename descclassname"><span class="pre">qmetro.protocols.mop.</span></span><span class="sig-name descname"><span class="pre">mop_adaptive_qfi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">channel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="qmetro.param_channel.html#qmetro.param_channel.param_channel.ParamChannel" title="qmetro.param_channel.param_channel.ParamChannel"><span class="pre">ParamChannel</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_channels</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">env_control</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">bool</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">env_inp_state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_pure_qfi</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">print_solver_messages</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="reference internal" href="_modules/qmetro/protocols/mop.html#mop_adaptive_qfi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qmetro.protocols.mop.mop_adaptive_qfi" title="Link to this definition"></a></dt>
<dd><p>Computes the comb QFI using minimization over purifications method
(MOP).</p>
<p>This function computes the QFI of comb consisting of
<cite>number_of_channels</cite> channels connected with their environments.
Notice that <cite>channel</cite> may be a single channel or a comb created by the
user. The resulting QFI is achievable when arbitrary adaptive control
can be applied in each step. Control may act between channels, but
also between different teeth of  <cite>channel</cite>, when <cite>channel</cite> represents
a comb.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>channel</strong> (<a class="reference internal" href="qmetro.param_channel.html#qmetro.param_channel.param_channel.ParamChannel" title="qmetro.param_channel.param_channel.ParamChannel"><em>ParamChannel</em></a>) – Parametrized channel characterizing signal encoding. Might be a
single channel or a comb.</p></li>
<li><p><strong>number_of_channels</strong> (<em>int</em>) – Number of elementary channels/combs linked to create the full
comb of interest.</p></li>
<li><p><strong>env_control</strong> (<em>bool</em><em> | </em><em>tuple</em><em>[</em><em>bool</em><em>, </em><em>bool</em><em>]</em><em>, </em><em>optional</em>) – If True, then adaptive control may also act on first input
and last output environment. If tuple, then
its elements refer to input and output environment respectively.</p></li>
<li><p><strong>env_inp_state</strong> (<em>np.ndarray</em><em> | </em><em>None</em><em>, </em><em>optional</em>) – Density matrix of the initial state of the environment. If None
then it becomes a maximally mixed state. This argument is
ignored when environment input is controlled.</p></li>
<li><p><strong>input_pure_qfi</strong> (<em>float</em><em>, </em><em>optional</em>) – The QFI of an additional pure parameter-dependent state.
This state can be treated as a first tooth of estimated comb.
By default, there is no such a state (input_pure_qfi = 0).
Non-zero values are typically used to calculate bounds.</p></li>
<li><p><strong>print_solver_messages</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to print solver messages to console during computation, by
default False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Quantum Fisher Information optimized over all comb controls.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r959199da222f-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Altherr, A. &amp; Yang, Y.(2021).
“Quantum Metrology for Non-Markovian Processes”
Physical Review Letters, 127, 060501
<a class="reference external" href="https://doi.org/10.1103/PhysRevLett.127.060501">https://doi.org/10.1103/PhysRevLett.127.060501</a></p>
</div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qmetro.protocols.mop.mop_channel_qfi">
<span class="sig-prename descclassname"><span class="pre">qmetro.protocols.mop.</span></span><span class="sig-name descname"><span class="pre">mop_channel_qfi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">channel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="qmetro.param_channel.html#qmetro.param_channel.param_channel.ParamChannel" title="qmetro.param_channel.param_channel.ParamChannel"><span class="pre">ParamChannel</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">env_inp_state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="reference internal" href="_modules/qmetro/protocols/mop.html#mop_channel_qfi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qmetro.protocols.mop.mop_channel_qfi" title="Link to this definition"></a></dt>
<dd><p>Computes quantum Fisher information for single parametrized channel
using minimization over purifications (MOP) method <a class="reference internal" href="#rbbac34db83fb-1" id="id6">[1]</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>channel</strong> (<a class="reference internal" href="qmetro.param_channel.html#qmetro.param_channel.param_channel.ParamChannel" title="qmetro.param_channel.param_channel.ParamChannel"><em>ParamChannel</em></a>) – Channel to compute quantum Fisher information for. In case this
argument is a comb created from single channels the whole comb
will be treated as a single channel.</p></li>
<li><p><strong>env_inp_state</strong> (<em>np.ndarray</em><em> | </em><em>None</em><em>, </em><em>optional</em>) – Density matrix of the initial state of the environment. If None
then it becomes a maximally mixed state.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>qfi</strong> – maximal QFI of a single channel.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rbbac34db83fb-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id6">1</a><span class="fn-bracket">]</span></span>
<p>Demkowicz-Dobrzański, R., Kołodyński, J. &amp; Guţă, M.
The elusive Heisenberg limit in quantum-enhanced metrology.
Nat Commun 3, 1063 (2012). <a class="reference external" href="https://doi.org/10.1038/ncomms2067">https://doi.org/10.1038/ncomms2067</a></p>
</div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qmetro.protocols.mop.mop_parallel_qfi">
<span class="sig-prename descclassname"><span class="pre">qmetro.protocols.mop.</span></span><span class="sig-name descname"><span class="pre">mop_parallel_qfi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">channel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="qmetro.param_channel.html#qmetro.param_channel.param_channel.ParamChannel" title="qmetro.param_channel.param_channel.ParamChannel"><span class="pre">ParamChannel</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_channels</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">env_inp_state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="reference internal" href="_modules/qmetro/protocols/mop.html#mop_parallel_qfi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qmetro.protocols.mop.mop_parallel_qfi" title="Link to this definition"></a></dt>
<dd><p>Computes quantum Fisher information in a scenario with parallel
channels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>channel</strong> (<a class="reference internal" href="qmetro.param_channel.html#qmetro.param_channel.param_channel.ParamChannel" title="qmetro.param_channel.param_channel.ParamChannel"><em>ParamChannel</em></a>) – Channel to compute quantum Fisher information for.</p></li>
<li><p><strong>number_of_channels</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of channel uses. In case <cite>channel</cite> is a comb created from
<cite>m</cite> single channels the total number of channels will be equal to
<cite>number_of_channels * m</cite>.</p></li>
<li><p><strong>env_inp_state</strong> (<em>np.ndarray</em><em> | </em><em>None</em><em>, </em><em>optional</em>) – Density matrix of the initial state of the environment. If None
then it becomes a maximally mixed state.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>qfi</strong> – Qunatum Fisher information.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r9b32ddfa1a10-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Demkowicz-Dobrzański, R., Kołodyński, J. &amp; Guţă, M.
The elusive Heisenberg limit in quantum-enhanced metrology.
Nat Commun 3, 1063 (2012). <a class="reference external" href="https://doi.org/10.1038/ncomms2067">https://doi.org/10.1038/ncomms2067</a></p>
</div>
</div>
</dd></dl>

</section>
<section id="module-qmetro.protocols.other">
<span id="qmetro-protocols-other-module"></span><h2>qmetro.protocols.other module<a class="headerlink" href="#module-qmetro.protocols.other" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="qmetro.protocols.other.multiple_measurements_qfi">
<span class="sig-prename descclassname"><span class="pre">qmetro.protocols.other.</span></span><span class="sig-name descname"><span class="pre">multiple_measurements_qfi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">single_qfis</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ns</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/qmetro/protocols/other.html#multiple_measurements_qfi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qmetro.protocols.other.multiple_measurements_qfi" title="Link to this definition"></a></dt>
<dd><p>For a list of QFIs for measurements with n = 1, 2, …, max_n probes
computes optimal QFI for each number of probes ditributed among
multiple measurments.</p>
<p>If QFI at some point starts to scale with number of probes sublinearly
for example:</p>
<blockquote>
<div><p>QFI1 = 1, QFI2 = 1.9, QFI3 = 2.7, …</p>
</div></blockquote>
<p>then it is advantegous to use probes in multiple measurements. In this
case:</p>
<blockquote>
<div><p>QFI1_opt = QFI1, QFI2_opt = 2 * QFI1, QFI3_opt = 3 * QFI, …</p>
</div></blockquote>
<p>In general, it requires solving a special case of a knapsack problem
<a class="reference internal" href="#rb713e63db40f-1" id="id7">[1]</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>single_qfis</strong> (<em>list</em><em>[</em><em>float</em><em>]</em>) – List of QFIs obtained in a single measurement such that
single_qfi[i] is QFI obtained with i + 1 probes.</p></li>
<li><p><strong>ns</strong> (<em>list</em><em>[</em><em>int</em><em>] </em><em>| </em><em>None</em><em>, </em><em>optional</em>) – If provided number of probes for single_qfi[i] is ns[i], by
default None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>qfis</strong> (<em>list[float]</em>) – List of optimal QFIs such that single_qfi[i] is QFI obtained with
i probes (note the shift -1 shift from single_qfis ordering).</p></li>
<li><p><strong>strategies</strong> (<em>list[list[int]]</em>) – List of optimal strategies. The element strategies[i] is a list
of single measurements constituting the optimal strategy for i
probes.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rb713e63db40f-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">1</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Knapsack_problem">https://en.wikipedia.org/wiki/Knapsack_problem</a></p>
</div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qmetro.protocols.other.state_cfi">
<span class="sig-prename descclassname"><span class="pre">qmetro.protocols.other.</span></span><span class="sig-name descname"><span class="pre">state_cfi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">povm</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-07</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="reference internal" href="_modules/qmetro/protocols/other.html#state_cfi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qmetro.protocols.other.state_cfi" title="Link to this definition"></a></dt>
<dd><p>Calculates classical Fisher information of a quantum state represented
by density matrix and its derivative over estimated parameter for
a given measurement represented by POVM.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state</strong> (<em>tuple</em><em>[</em><em>np.ndarray</em><em>, </em><em>np.ndarray</em><em>]</em>) – <dl class="simple">
<dt>A tuple containing:</dt><dd><ol class="arabic simple">
<li><dl class="simple">
<dt>rho: np.ndarray</dt><dd><p>Density matrix</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>drho: np.ndarray</dt><dd><p>Derivative of density matrix over estimated parameter</p>
</dd>
</dl>
</li>
</ol>
</dd>
</dl>
</p></li>
<li><p><strong>povm</strong> (<em>list</em><em>[</em><em>np.ndarray</em><em>]</em>) – List of operators defining a generalized measurement (POVM)</p></li>
<li><p><strong>eps</strong> (<em>float</em><em>, </em><em>optional</em>) – probabilities smaller then eps will not contribute to cfi</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Classical Fisher information for input state and measurement</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qmetro.protocols.other.state_qfi">
<span class="sig-prename descclassname"><span class="pre">qmetro.protocols.other.</span></span><span class="sig-name descname"><span class="pre">state_qfi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/qmetro/protocols/other.html#state_qfi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qmetro.protocols.other.state_qfi" title="Link to this definition"></a></dt>
<dd><p>Calculates quantum Fisher information of a quantum state represented
by density matrix and its derivative over estimated parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>state</strong> (<em>tuple</em><em>[</em><em>np.ndarray</em><em>, </em><em>np.ndarray</em><em>]</em>) – <dl class="simple">
<dt>A tuple containing:</dt><dd><ol class="arabic simple">
<li><dl class="simple">
<dt>rho: np.ndarray</dt><dd><p>Density matrix</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>drho: np.ndarray</dt><dd><p>Derivative of density matrix over estimated parameter</p>
</dd>
</dl>
</li>
</ol>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>float</em> – State qfi</p></li>
<li><p><em>np.ndarray</em> – Symmetric logarithmic derivative (SLD) matrix</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-qmetro.protocols.warnings">
<span id="qmetro-protocols-warnings-module"></span><h2>qmetro.protocols.warnings module<a class="headerlink" href="#module-qmetro.protocols.warnings" title="Link to this heading"></a></h2>
</section>
<section id="module-qmetro.protocols">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-qmetro.protocols" title="Link to this heading"></a></h2>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="qmetro.param_channel.html" class="btn btn-neutral float-left" title="qmetro.param_channel package" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="qmetro.qmtensor.html" class="btn btn-neutral float-right" title="qmetro.qmtensor package" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Piotr Dulian.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>