

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>qmetro.protocols.iss &mdash; QMetro++ 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=8d563738"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            QMetro++
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../qmetro.html">Documentation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">QMetro++</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">qmetro.protocols.iss</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for qmetro.protocols.iss</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Hashable</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">cycle</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">warnings</span><span class="w"> </span><span class="kn">import</span> <span class="n">warn</span><span class="p">,</span> <span class="n">filterwarnings</span><span class="p">,</span> <span class="n">catch_warnings</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">..iss_opt</span><span class="w"> </span><span class="kn">import</span> <span class="n">iss_opt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..qmtensor</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">SpaceDict</span><span class="p">,</span> <span class="n">TensorNetwork</span><span class="p">,</span> <span class="n">VarTensor</span><span class="p">,</span> <span class="n">ConstTensor</span><span class="p">,</span>
    <span class="n">mps_var_tnet</span><span class="p">,</span> <span class="n">choi_identity</span><span class="p">,</span> <span class="n">mpo_measure_var_tnet</span><span class="p">,</span> <span class="n">measure_var</span><span class="p">,</span>
    <span class="n">input_state_var</span><span class="p">,</span> <span class="n">comb_var</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..param_channel</span><span class="w"> </span><span class="kn">import</span> <span class="n">ParamChannel</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.errors</span><span class="w"> </span><span class="kn">import</span> <span class="n">EnvDimsError</span><span class="p">,</span> <span class="n">UnitalDimsError</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.warnings</span><span class="w"> </span><span class="kn">import</span> <span class="n">ENV_FOR_SINGLE</span><span class="p">,</span> <span class="n">COMB_FOR_SINGLE</span>




<div class="viewcode-block" id="iss_channel_qfi">
<a class="viewcode-back" href="../../../qmetro.protocols.html#qmetro.protocols.iss.iss_channel_qfi">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">iss_channel_qfi</span><span class="p">(</span><span class="n">channel</span><span class="p">:</span> <span class="n">ParamChannel</span><span class="p">,</span> <span class="n">ancilla_dim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">env_inp_state</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">artificial_noise_after</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes quantum Fisher information for a single parametrized channel</span>
<span class="sd">    using iterative see-saw (ISS) method [1]_.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    channel : ParamChannel</span>
<span class="sd">        Channel to compute quantum Fisher information for. In case this</span>
<span class="sd">        argument is a comb created from single channels the whole comb</span>
<span class="sd">        will be treated as a single channel.</span>
<span class="sd">    ancilla_dim : int, optional</span>
<span class="sd">        Dimension of the ancilla, by default 1.</span>
<span class="sd">    env_inp_state : np.ndarray | None, optional</span>
<span class="sd">        Density matrix of the initial state of the environment. If None</span>
<span class="sd">        then it becomes a maximally mixed state.</span>
<span class="sd">    artificial_noise_after : bool | None, optional</span>
<span class="sd">        Whether auxiliary noise is added after the channel:</span>
<span class="sd">        - True : auxiliary noise is added after the channel,</span>
<span class="sd">        - False : auxiliary noise is added before the channel,</span>
<span class="sd">        - None : auxiliary noise is not used.</span>
<span class="sd">        By default True.</span>
<span class="sd">    kwargs :</span>
<span class="sd">        Additional arguments passed on to `iss` optimization function.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    qfi : float</span>
<span class="sd">        Quantum Fisher information.</span>
<span class="sd">    qfis : list[float]</span>
<span class="sd">        QFI per algorithm iteration number.</span>
<span class="sd">    input_state : np.ndarray</span>
<span class="sd">        Density matrix of the optimal input state. The input space of</span>
<span class="sd">        the channel goes first and the ancilla second.</span>
<span class="sd">    sld : np.ndarray</span>
<span class="sd">        Symmetric loagarithmic derivative. The output space of</span>
<span class="sd">        the channel goes first and the ancilla second.</span>
<span class="sd">    status : bool</span>
<span class="sd">        True if the algorithm converged, False otherwise.</span>

<span class="sd">    References</span>
<span class="sd">    ------</span>
<span class="sd">    .. [1] S. Kurdzia≈Çek et al. Quantum metrology using quantum combs and</span>
<span class="sd">           tensor network formalism, New Journal of Physics (2024).</span>
<span class="sd">           https://doi.org/10.1088/1367-2630/ada8d1</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">channel</span><span class="o">.</span><span class="n">trivial_env</span><span class="p">:</span>
        <span class="n">warn</span><span class="p">(</span><span class="n">ENV_FOR_SINGLE</span><span class="p">)</span>
        <span class="n">channel</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">trace_env</span><span class="p">(</span><span class="n">env_inp_state</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">channel</span><span class="o">.</span><span class="n">is_comb</span><span class="p">:</span>
        <span class="n">warn</span><span class="p">(</span><span class="n">COMB_FOR_SINGLE</span><span class="p">)</span>

    <span class="n">output_dim</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">output_dim</span>
    <span class="n">input_dim</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">input_dim</span>

    <span class="n">sd</span> <span class="o">=</span> <span class="n">SpaceDict</span><span class="p">()</span>
    <span class="n">INPUT</span> <span class="o">=</span> <span class="s1">&#39;INPUT&#39;</span>
    <span class="n">OUTPUT</span> <span class="o">=</span> <span class="s1">&#39;OUTPUT&#39;</span>
    <span class="n">ANCILLA</span> <span class="o">=</span> <span class="s1">&#39;ANCILLA&#39;</span>
    <span class="n">sd</span><span class="p">[</span><span class="n">INPUT</span><span class="p">]</span> <span class="o">=</span> <span class="n">input_dim</span>
    <span class="n">sd</span><span class="p">[</span><span class="n">OUTPUT</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_dim</span>
    <span class="n">sd</span><span class="p">[</span><span class="n">ANCILLA</span><span class="p">]</span> <span class="o">=</span> <span class="n">ancilla_dim</span>

    <span class="n">RHO0</span> <span class="o">=</span> <span class="s1">&#39;RHO0&#39;</span>
    <span class="n">rho0</span> <span class="o">=</span> <span class="n">input_state_var</span><span class="p">([</span><span class="n">INPUT</span><span class="p">,</span> <span class="n">ANCILLA</span><span class="p">],</span> <span class="n">RHO0</span><span class="p">,</span> <span class="n">sd</span><span class="p">)</span>

    <span class="n">chann_ten</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="n">INPUT</span><span class="p">],</span> <span class="p">[</span><span class="n">OUTPUT</span><span class="p">],</span> <span class="n">sdict</span><span class="o">=</span><span class="n">sd</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;CHANNEL&#39;</span><span class="p">)</span>

    <span class="n">MEASUREMENT</span> <span class="o">=</span> <span class="s1">&#39;MEASUREMENT&#39;</span>
    <span class="n">measure</span> <span class="o">=</span> <span class="n">measure_var</span><span class="p">([</span><span class="n">OUTPUT</span><span class="p">,</span> <span class="n">ANCILLA</span><span class="p">],</span> <span class="n">MEASUREMENT</span><span class="p">,</span> <span class="n">sd</span><span class="p">)</span>

    <span class="n">tn</span> <span class="o">=</span> <span class="n">rho0</span> <span class="o">*</span> <span class="n">chann_ten</span> <span class="o">*</span> <span class="n">measure</span>

    <span class="k">if</span> <span class="n">artificial_noise_after</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">art_noise_spaces</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">elif</span> <span class="n">artificial_noise_after</span><span class="p">:</span>
        <span class="n">art_noise_spaces</span> <span class="o">=</span> <span class="p">[[</span><span class="n">OUTPUT</span><span class="p">]]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">art_noise_spaces</span> <span class="o">=</span> <span class="p">[[</span><span class="n">INPUT</span><span class="p">]]</span>

    <span class="n">qfi</span><span class="p">,</span> <span class="n">qfis</span><span class="p">,</span> <span class="n">new_tn</span><span class="p">,</span> <span class="n">status</span> <span class="o">=</span> <span class="n">iss_opt</span><span class="p">(</span>
        <span class="n">tn</span><span class="p">,</span> <span class="n">art_noise_spaces</span><span class="o">=</span><span class="n">art_noise_spaces</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span>

    <span class="n">rho0_arr</span> <span class="o">=</span> <span class="n">new_tn</span><span class="o">.</span><span class="n">tensors</span><span class="p">[</span><span class="n">RHO0</span><span class="p">]</span><span class="o">.</span><span class="n">choi</span><span class="p">([</span><span class="n">INPUT</span><span class="p">,</span> <span class="n">ANCILLA</span><span class="p">])</span>
    <span class="n">sld_arr</span> <span class="o">=</span> <span class="n">new_tn</span><span class="o">.</span><span class="n">tensors</span><span class="p">[</span><span class="n">MEASUREMENT</span><span class="p">]</span><span class="o">.</span><span class="n">choi</span><span class="p">([</span><span class="n">OUTPUT</span><span class="p">,</span> <span class="n">ANCILLA</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">qfi</span><span class="p">,</span> <span class="n">qfis</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rho0_arr</span><span class="p">,</span> <span class="n">sld_arr</span><span class="p">,</span> <span class="n">status</span></div>



<div class="viewcode-block" id="iss_parallel_qfi">
<a class="viewcode-back" href="../../../qmetro.protocols.html#qmetro.protocols.iss.iss_parallel_qfi">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">iss_parallel_qfi</span><span class="p">(</span><span class="n">channel</span><span class="p">:</span> <span class="n">ParamChannel</span><span class="p">,</span> <span class="n">number_of_channels</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">ancilla_dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">artificial_noise_after</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">env_inp_state</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes quantum Fisher information for channels in parallel using</span>
<span class="sd">    iterative see-saw (ISS) algorithm [1]_.</span>

<span class="sd">    In parallel strategy all channels are simultaneously probed by an</span>
<span class="sd">    entangled input state and their output is collectively measured.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    channel : ParamChannel</span>
<span class="sd">        Channel to compute quantum Fisher information for.</span>
<span class="sd">    number_of_channels : int</span>
<span class="sd">        Number of channel uses. In case `channel` is a comb created from</span>
<span class="sd">        `m` single channels the total number of channels will be equal to</span>
<span class="sd">        `number_of_channels * m`.</span>
<span class="sd">    ancilla_dim : int</span>
<span class="sd">        Dimension of the ancilla space.</span>
<span class="sd">    artificial_noise_after : bool | None, optional</span>
<span class="sd">        Whether auxiliary noise is added after the channel:</span>
<span class="sd">        - True : auxiliary noise is added after the channel,</span>
<span class="sd">        - False : auxiliary noise is added before the channel,</span>
<span class="sd">        - None : auxiliary noise is not used.</span>
<span class="sd">        By default None.</span>
<span class="sd">    env_inp_state : np.ndarray | None, optional</span>
<span class="sd">        Density matrix of the initial state of the environment. If None</span>
<span class="sd">        then it becomes a maximally mixed state.</span>
<span class="sd">    kwargs :</span>
<span class="sd">        Additional arguments passed on to `iss` optimization function.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    qfi : float</span>
<span class="sd">        Qunatum Fisher information.</span>
<span class="sd">    qfis : list[float]</span>
<span class="sd">        QFI per algorithm iteration number.</span>
<span class="sd">    input_state : np.ndarray</span>
<span class="sd">        Density matrix of the optimal input state. The input spaces of</span>
<span class="sd">        the channels go first and the ancilla goes last.</span>
<span class="sd">    sld : np.ndarray</span>
<span class="sd">        Symmetric loagarithmic derivative. The output spaces of</span>
<span class="sd">        the channels go first and the ancilla goes last.</span>
<span class="sd">    status : bool</span>
<span class="sd">        True if the algorithm converged, False otherwise.</span>

<span class="sd">    References</span>
<span class="sd">    -------</span>
<span class="sd">    .. [1] K. Chabuda et al. Tensor-Network Approach for Quantum Metrology</span>
<span class="sd">           in Many-Body Quantum Systems, Nature Commun 11, 250 (2020).</span>
<span class="sd">           https://doi.org/10.1038/s41467-019-13735-9</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">env_inp_dim</span> <span class="o">!=</span> <span class="n">channel</span><span class="o">.</span><span class="n">env_out_dim</span>
        <span class="ow">and</span> <span class="n">number_of_channels</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">EnvDimsError</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">env_inp_dim</span><span class="p">,</span> <span class="n">channel</span><span class="o">.</span><span class="n">env_out_dim</span><span class="p">)</span>

    <span class="n">c</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">markov_series</span><span class="p">(</span><span class="n">number_of_channels</span><span class="p">)</span><span class="o">.</span><span class="n">trace_env</span><span class="p">(</span><span class="n">env_inp_state</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">merge_spaces</span><span class="p">()</span>
    <span class="k">with</span> <span class="n">catch_warnings</span><span class="p">():</span>
        <span class="n">filterwarnings</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="n">COMB_FOR_SINGLE</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">iss_channel_qfi</span><span class="p">(</span>
            <span class="n">c</span><span class="p">,</span> <span class="n">ancilla_dim</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">artificial_noise_after</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span></div>



<div class="viewcode-block" id="iss_tnet_parallel_qfi">
<a class="viewcode-back" href="../../../qmetro.protocols.html#qmetro.protocols.iss.iss_tnet_parallel_qfi">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">iss_tnet_parallel_qfi</span><span class="p">(</span><span class="n">channel</span><span class="p">:</span> <span class="n">ParamChannel</span><span class="p">,</span> <span class="n">number_of_channels</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">ancilla_dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">mps_bond_dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">measure_bond_dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">artificial_noise_after</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">env_inp_state</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
    <span class="nb">bool</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes quantum Fisher information for channels in parallel using</span>
<span class="sd">    iterative see-saw algorithm and tensor networks, that is matrix</span>
<span class="sd">    product state (MPS) and matrix product operators (MPOs).</span>

<span class="sd">    In parallel strategy all channels are simultaneously probed by an</span>
<span class="sd">    entangled input state and their output is collectively measured.</span>

<span class="sd">    In the approach with tensor networks the input state is expressed as</span>
<span class="sd">    a tensor network in a shape of a line where i-th tensor represents</span>
<span class="sd">    part of the input state that goes to the i-th probe channel and</span>
<span class="sd">    has is connected with two other tensors (one tensor in case of the</span>
<span class="sd">    first and the last one) with bond spaces/indices [1]_.</span>

<span class="sd">    The measurement and then the symmetric logarithmic derivative (SLD)</span>
<span class="sd">    matrix is expressed as an analogous tensor network (representing</span>
<span class="sd">    operators instead of states) called matrix product operator (MPO).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    channel : ParamChannel</span>
<span class="sd">        Channel to compute quantum Fisher information for.</span>
<span class="sd">    number_of_channels : int</span>
<span class="sd">        Number of channel uses. In case `channel` is a comb created from</span>
<span class="sd">        `m` single channels the total number of channels will be equal to</span>
<span class="sd">        `number_of_channels * m`.</span>
<span class="sd">    ancilla_dim : int</span>
<span class="sd">        Dimension of the ancilla space.</span>
<span class="sd">    mps_bond_dim : int</span>
<span class="sd">        Dimension of the bond space of the input state which is a matrix</span>
<span class="sd">        product state (MPS).</span>
<span class="sd">    measure_bond_dim : int</span>
<span class="sd">        Dimension of the bond space of the measurement (SLD) which is</span>
<span class="sd">        a matrix product operator.</span>
<span class="sd">    artificial_noise_after : bool | None, optional</span>
<span class="sd">        Whether auxiliary noise is added after the channel:</span>
<span class="sd">        - True : auxiliary noise is added after the channel,</span>
<span class="sd">        - False : auxiliary noise is added before the channel,</span>
<span class="sd">        - None : auxiliary noise is not used.</span>
<span class="sd">        By default None.</span>
<span class="sd">    env_inp_state : np.ndarray | None, optional</span>
<span class="sd">        Density matrix of the initial state of the environment. If None</span>
<span class="sd">        then it becomes a maximally mixed state.</span>
<span class="sd">    kwargs :</span>
<span class="sd">        Additional arguments passed on to `iss` optimization function.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    qfi : float</span>
<span class="sd">        Qunatum Fisher information.</span>
<span class="sd">    qfis : list[float]</span>
<span class="sd">        QFI per algorithm iteration number.</span>
<span class="sd">    input_state : list[np.array]</span>
<span class="sd">        The optimal matrix product state (MPS). The i-th tensor on the list</span>
<span class="sd">        - R_i is the input of the i-th channel except the last which is the</span>
<span class="sd">        part going to ancilla. Its indices are in the order: bond space</span>
<span class="sd">        connecting to the previous tensor (if it exists), input state of</span>
<span class="sd">        the channel/ancilla, bond space connecting to the next tensor (if</span>
<span class="sd">        it exists).</span>
<span class="sd">    sld : list[np.array]</span>
<span class="sd">        Matrix product operator (MPO) of the optimal symmetric logarithmic</span>
<span class="sd">        derivative (SLD). The i-th tensor on the list - L_i is sld MPO</span>
<span class="sd">        elemnt on the output of the i-th channel except the last one which</span>
<span class="sd">        is on ancilla. Its indices/spaces are in the order: bond space</span>
<span class="sd">        connecting to the previous tensor (if it exists), channel output</span>
<span class="sd">        or ancilla, bond space connecting to the next tensor (if it</span>
<span class="sd">        exists).</span>
<span class="sd">    status : bool</span>
<span class="sd">        True if the algorithm converged, False otherwise.</span>

<span class="sd">    References</span>
<span class="sd">    -------</span>
<span class="sd">    .. [1] K. Chabuda et al. Tensor-Network Approach for Quantum Metrology</span>
<span class="sd">           in Many-Body Quantum Systems, Nature Commun 11, 250 (2020).</span>
<span class="sd">           https://doi.org/10.1038/s41467-019-13735-9</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">channel</span><span class="o">.</span><span class="n">env_inp_dim</span> <span class="o">!=</span> <span class="n">channel</span><span class="o">.</span><span class="n">env_out_dim</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">number_of_channels</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">channel</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">trace_env</span><span class="p">(</span><span class="n">env_inp_state</span><span class="p">)</span>
            <span class="c1"># To avoid error for env_inp_tensor declaration:</span>
            <span class="n">env_inp_state</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">EnvDimsError</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">env_inp_dim</span><span class="p">,</span> <span class="n">channel</span><span class="o">.</span><span class="n">env_out_dim</span><span class="p">)</span>

    <span class="n">env_dim</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">env_inp_dim</span>

    <span class="n">n_combs</span> <span class="o">=</span> <span class="n">number_of_channels</span>
    <span class="n">ch_per_comb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">input_spaces</span><span class="p">)</span>
    <span class="n">n_ch</span> <span class="o">=</span> <span class="n">n_combs</span> <span class="o">*</span> <span class="n">ch_per_comb</span>
    <span class="n">n_a</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">n_ch</span> <span class="o">+</span> <span class="n">n_a</span>

    <span class="n">sd</span> <span class="o">=</span> <span class="n">SpaceDict</span><span class="p">()</span>
    <span class="n">inp</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;IN&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_ch</span><span class="p">)]</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;OUT&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_ch</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">space</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">cycle</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">input_dims</span><span class="p">)):</span>
        <span class="n">sd</span><span class="p">[</span><span class="n">space</span><span class="p">]</span> <span class="o">=</span> <span class="n">dim</span>
    <span class="k">for</span> <span class="n">space</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">cycle</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">output_dims</span><span class="p">)):</span>
        <span class="n">sd</span><span class="p">[</span><span class="n">space</span><span class="p">]</span> <span class="o">=</span> <span class="n">dim</span>
    <span class="n">anc</span> <span class="o">=</span> <span class="n">sd</span><span class="o">.</span><span class="n">arrange_spaces</span><span class="p">(</span><span class="n">n_a</span><span class="p">,</span> <span class="n">ancilla_dim</span><span class="p">,</span> <span class="s1">&#39;ANC&#39;</span><span class="p">)</span>
    <span class="n">env</span> <span class="o">=</span> <span class="n">sd</span><span class="o">.</span><span class="n">arrange_spaces</span><span class="p">(</span><span class="n">n_combs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">env_dim</span><span class="p">,</span> <span class="s1">&#39;ENV&#39;</span><span class="p">)</span>

    <span class="n">RHO0</span> <span class="o">=</span> <span class="s1">&#39;RHO0&#39;</span>
    <span class="n">mps</span><span class="p">,</span> <span class="n">mps_names</span><span class="p">,</span> <span class="n">mps_bonds</span> <span class="o">=</span> <span class="n">mps_var_tnet</span><span class="p">(</span>
        <span class="n">inp</span> <span class="o">+</span> <span class="n">anc</span><span class="p">,</span> <span class="n">RHO0</span><span class="p">,</span> <span class="n">sd</span><span class="p">,</span> <span class="n">mps_bond_dim</span>
    <span class="p">)</span>

    <span class="n">ENV_INP_STATE</span> <span class="o">=</span> <span class="s1">&#39;ENVIRONMENT INPUT STATE&#39;</span>
    <span class="k">if</span> <span class="n">env_inp_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">env_inp_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">env_dim</span><span class="p">)</span> <span class="o">/</span> <span class="n">env_dim</span>
    <span class="n">env_inp_tensor</span> <span class="o">=</span> <span class="n">ConstTensor</span><span class="p">(</span>
        <span class="p">[</span><span class="n">env</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">sdict</span><span class="o">=</span><span class="n">sd</span><span class="p">,</span> <span class="n">output_spaces</span><span class="o">=</span><span class="p">[</span><span class="n">env</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">name</span><span class="o">=</span><span class="n">ENV_INP_STATE</span><span class="p">,</span>
        <span class="n">choi</span><span class="o">=</span><span class="n">env_inp_state</span>
    <span class="p">)</span>

    <span class="n">ENV_TRACE</span> <span class="o">=</span> <span class="s1">&#39;ENVIRONMENT TRACE&#39;</span>
    <span class="n">env_trace</span> <span class="o">=</span> <span class="n">choi_identity</span><span class="p">([</span><span class="n">env</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">sdict</span><span class="o">=</span><span class="n">sd</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">ENV_TRACE</span><span class="p">)</span>

    <span class="n">CHANNEL</span> <span class="o">=</span> <span class="s1">&#39;CHANNEL&#39;</span>
    <span class="n">comb_tensors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">comb_ten_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_combs</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">ch_per_comb</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">ch_per_comb</span>

        <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">CHANNEL</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">comb_tensor</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span>
            <span class="n">inp</span><span class="p">[</span><span class="n">x</span><span class="p">:</span><span class="n">y</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="n">x</span><span class="p">:</span><span class="n">y</span><span class="p">],</span> <span class="n">env</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">env</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">sd</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span>
        <span class="p">)</span>

        <span class="n">comb_ten_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">comb_tensors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">comb_tensor</span><span class="p">)</span>
    <span class="n">channels_tnet</span> <span class="o">=</span> <span class="n">TensorNetwork</span><span class="p">(</span><span class="n">comb_tensors</span><span class="p">,</span> <span class="n">sd</span><span class="p">,</span> <span class="n">CHANNEL</span><span class="p">)</span>

    <span class="n">MEASUREMENT</span> <span class="o">=</span> <span class="s1">&#39;MEASUREMENT&#39;</span>
    <span class="n">meas_mpo</span><span class="p">,</span> <span class="n">meas_names</span><span class="p">,</span> <span class="n">meas_bonds</span> <span class="o">=</span> <span class="n">mpo_measure_var_tnet</span><span class="p">(</span>
        <span class="n">out</span> <span class="o">+</span> <span class="n">anc</span><span class="p">,</span> <span class="n">MEASUREMENT</span><span class="p">,</span> <span class="n">sd</span><span class="p">,</span> <span class="n">measure_bond_dim</span>
    <span class="p">)</span>

    <span class="n">tn</span> <span class="o">=</span> <span class="n">TensorNetwork</span><span class="p">(</span>
        <span class="p">[</span><span class="n">mps</span><span class="p">,</span> <span class="n">env_inp_tensor</span><span class="p">,</span> <span class="n">channels_tnet</span><span class="p">,</span> <span class="n">env_trace</span><span class="p">,</span> <span class="n">meas_mpo</span><span class="p">],</span>
        <span class="n">sdict</span><span class="o">=</span><span class="n">sd</span>
    <span class="p">)</span>

    <span class="n">contraction_order</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">contraction_order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mps_names</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">contraction_order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ENV_INP_STATE</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_ch</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">%</span> <span class="n">ch_per_comb</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span> <span class="o">/</span> <span class="n">ch_per_comb</span><span class="p">)</span>
            <span class="n">contraction_order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">comb_ten_names</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="n">n_combs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">contraction_order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ENV_TRACE</span><span class="p">)</span>
        <span class="n">contraction_order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">meas_names</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">artificial_noise_after</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">noise_spaces</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">elif</span> <span class="n">artificial_noise_after</span><span class="p">:</span>
        <span class="n">noise_spaces</span> <span class="o">=</span> <span class="p">[[</span><span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_ch</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">noise_spaces</span> <span class="o">=</span> <span class="p">[[</span><span class="n">inp</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_ch</span><span class="p">)]</span>

    <span class="n">qfi</span><span class="p">,</span> <span class="n">qfis</span><span class="p">,</span> <span class="n">new_tn</span><span class="p">,</span> <span class="n">status</span> <span class="o">=</span> <span class="n">iss_opt</span><span class="p">(</span>
        <span class="n">tn</span><span class="p">,</span> <span class="n">art_noise_spaces</span><span class="o">=</span><span class="n">noise_spaces</span><span class="p">,</span>
        <span class="n">contraction_order</span><span class="o">=</span><span class="n">contraction_order</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span>

    <span class="n">mps_result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">sld_result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">mps_name</span><span class="p">,</span> <span class="n">sld_name</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">mps_names</span><span class="p">,</span> <span class="n">meas_names</span><span class="p">)):</span>
        <span class="n">mps_el</span> <span class="o">=</span> <span class="n">new_tn</span><span class="o">.</span><span class="n">tensors</span><span class="p">[</span><span class="n">mps_name</span><span class="p">]</span>
        <span class="n">sld_el</span> <span class="o">=</span> <span class="n">new_tn</span><span class="o">.</span><span class="n">tensors</span><span class="p">[</span><span class="n">sld_name</span><span class="p">]</span>

        <span class="n">mps_spaces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sld_spaces</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mps_spaces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mps_bonds</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">sld_spaces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">meas_bonds</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">mps_names</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">mps_spaces</span> <span class="o">+=</span> <span class="p">[</span><span class="n">inp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">mps_bonds</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="n">sld_spaces</span> <span class="o">+=</span> <span class="p">[</span><span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">meas_bonds</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mps_spaces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">anc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">sld_spaces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">anc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">mps_ten</span> <span class="o">=</span> <span class="n">mps_el</span><span class="o">.</span><span class="n">to_mps</span><span class="p">(</span><span class="n">mps_spaces</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">sld_ten</span> <span class="o">=</span> <span class="n">sld_el</span><span class="o">.</span><span class="n">reorder</span><span class="p">(</span><span class="n">sld_spaces</span><span class="p">)</span><span class="o">.</span><span class="n">array</span>

        <span class="n">mps_result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mps_ten</span><span class="p">)</span>
        <span class="n">sld_result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sld_ten</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">qfi</span><span class="p">,</span> <span class="n">qfis</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mps_result</span><span class="p">,</span> <span class="n">sld_result</span><span class="p">,</span> <span class="n">status</span></div>



<div class="viewcode-block" id="iss_adaptive_qfi">
<a class="viewcode-back" href="../../../qmetro.protocols.html#qmetro.protocols.iss.iss_adaptive_qfi">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">iss_adaptive_qfi</span><span class="p">(</span><span class="n">channel</span> <span class="p">:</span> <span class="n">ParamChannel</span><span class="p">,</span> <span class="n">number_of_channels</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">ancilla_dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">artificial_noise_after</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">env_inp_state</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes quantum Fisher information channels in an adaptive control</span>
<span class="sd">    system called quantum comb using iterative see-saw (ISS) algorithm</span>
<span class="sd">    [1]_.</span>

<span class="sd">    In this approach we consider n copies of a quantum channel Phi:</span>
<span class="sd">    </span>
<span class="sd">        Phi_i: L(env_i (x) in_i) -&gt; L(env_i+1 (x) out_i)</span>
<span class="sd">        for i = 0, ..., n - 1,</span>

<span class="sd">    put in a quantum comb C from a set:</span>

<span class="sd">        Comb[(Null, in_0), (out_0, in_1), ..., (out_n-2, in_n-1 (x) anc)],</span>

<span class="sd">    and a measurement at the end:</span>

<span class="sd">        P: L(out_n-1 (x) anc) -&gt; R,</span>

<span class="sd">    where (x) denotes a tensor product of Hilbert spaces.</span>

<span class="sd">    The input of the first environment space (env_0) is initialized with</span>
<span class="sd">    `env_inp_state` and the last environment spcace (env_n) is traced out.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    channel : ParamChannel</span>
<span class="sd">        Channel to compute quantum Fisher information for. In case this</span>
<span class="sd">        argument is a comb created from single channels the control</span>
<span class="sd">        operation (comb&#39;s tooth) will be put between every **single**</span>
<span class="sd">        channel.</span>
<span class="sd">    number_of_channels : int</span>
<span class="sd">        Number of channel uses. In case `channel` is a comb created from</span>
<span class="sd">        `m` single channels the total number of channels will be equal to</span>
<span class="sd">        `number_of_channels * m`.</span>
<span class="sd">    ancilla_dim : int</span>
<span class="sd">        Dimension of the ancilla space connecting controls (teeth),</span>
<span class="sd">        dim(anc).</span>
<span class="sd">    artificial_noise_after : bool, optional</span>
<span class="sd">        Whether auxiliary noise is added after the channel:</span>
<span class="sd">        - True : auxiliary noise is added after the channel,</span>
<span class="sd">        - False : auxiliary noise is added before the channel,</span>
<span class="sd">        - None : auxiliary noise is not used.</span>
<span class="sd">        By default True.</span>
<span class="sd">    env_inp_state : np.ndarray | None, optional</span>
<span class="sd">        Density matrix of the initial state of the environment. If None</span>
<span class="sd">        then it becomes a maximally mixed state.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    qfi : float</span>
<span class="sd">        Quantum Fisher information.</span>
<span class="sd">    qfis : list[floats]</span>
<span class="sd">        A list of quantum Fisher informations acvhieved in each iteration.</span>
<span class="sd">        The last value in the list is the final solution.</span>
<span class="sd">    comb : np.ndarray</span>
<span class="sd">        Choi matrix of the optimal comb with spaces in order: inp_0, ...,</span>
<span class="sd">        inp_n-1, anc, out_0, ..., out_n-2.</span>
<span class="sd">    L : np.ndarray</span>
<span class="sd">        Optimal syymetric logaritmic derivative (SLD) matrix with spaces</span>
<span class="sd">        in order: out_n-1, anc.</span>
<span class="sd">    status : bool</span>
<span class="sd">        True if the algorithm converged, False otherwise.</span>

<span class="sd">    References</span>
<span class="sd">    -------</span>
<span class="sd">    .. [1] S. Kurdzia≈Çek et al. Quantum metrology using quantum combs and</span>
<span class="sd">           tensor network formalism, New Journal of Physics (2024).</span>
<span class="sd">           https://doi.org/10.1088/1367-2630/ada8d1</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">channel</span><span class="o">.</span><span class="n">env_inp_dim</span> <span class="o">!=</span> <span class="n">channel</span><span class="o">.</span><span class="n">env_out_dim</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">number_of_channels</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">channel</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">trace_env</span><span class="p">(</span><span class="n">env_inp_state</span><span class="p">)</span>
            <span class="c1"># To avoid error for env_inp_tensor declaration:</span>
            <span class="n">env_inp_state</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">EnvDimsError</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">env_inp_dim</span><span class="p">,</span> <span class="n">channel</span><span class="o">.</span><span class="n">env_out_dim</span><span class="p">)</span>
    <span class="n">env_dim</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">env_inp_dim</span>

    <span class="c1"># ch_comb for number &quot;channel combs&quot; i.e. combs of channels to</span>
    <span class="c1"># differentiate from comb of controls.</span>
    <span class="n">n_ch_comb</span> <span class="o">=</span> <span class="n">number_of_channels</span>
    <span class="n">ch_per_ch_comb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">input_spaces</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">n_ch_comb</span> <span class="o">*</span> <span class="n">ch_per_ch_comb</span>

    <span class="n">sd</span> <span class="o">=</span> <span class="n">SpaceDict</span><span class="p">()</span>
    <span class="n">inp</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;IN&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;OUT&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">space</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">cycle</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">input_dims</span><span class="p">)):</span>
        <span class="n">sd</span><span class="p">[</span><span class="n">space</span><span class="p">]</span> <span class="o">=</span> <span class="n">dim</span>
    <span class="k">for</span> <span class="n">space</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">cycle</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">output_dims</span><span class="p">)):</span>
        <span class="n">sd</span><span class="p">[</span><span class="n">space</span><span class="p">]</span> <span class="o">=</span> <span class="n">dim</span>
    <span class="n">anc</span> <span class="o">=</span> <span class="s1">&#39;ANC&#39;</span>
    <span class="n">sd</span><span class="p">[</span><span class="n">anc</span><span class="p">]</span> <span class="o">=</span> <span class="n">ancilla_dim</span>
    <span class="n">env</span> <span class="o">=</span> <span class="n">sd</span><span class="o">.</span><span class="n">arrange_spaces</span><span class="p">(</span><span class="n">n_ch_comb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">env_dim</span><span class="p">,</span> <span class="s1">&#39;ENV&#39;</span><span class="p">)</span>

    <span class="n">COMB</span> <span class="o">=</span> <span class="s1">&#39;COMB&#39;</span>
    <span class="n">comb_structure</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">tooth_inp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">tooth_out</span> <span class="o">=</span> <span class="p">[</span><span class="n">inp</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">tooth_inp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">tooth_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">anc</span><span class="p">)</span>

        <span class="n">comb_structure</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">tooth_inp</span><span class="p">,</span> <span class="n">tooth_out</span><span class="p">))</span>
    <span class="n">comb</span> <span class="o">=</span> <span class="n">comb_var</span><span class="p">(</span><span class="n">comb_structure</span><span class="p">,</span> <span class="n">sdict</span><span class="o">=</span><span class="n">sd</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">COMB</span><span class="p">)</span>

    <span class="n">ENV_INP_STATE</span> <span class="o">=</span> <span class="s1">&#39;ENVIRONMENT INPUT STATE&#39;</span>
    <span class="k">if</span> <span class="n">env_inp_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">env_inp_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">env_dim</span><span class="p">)</span> <span class="o">/</span> <span class="n">env_dim</span>
    <span class="n">env_inp_tensor</span> <span class="o">=</span> <span class="n">ConstTensor</span><span class="p">(</span>
        <span class="p">[</span><span class="n">env</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">sdict</span><span class="o">=</span><span class="n">sd</span><span class="p">,</span> <span class="n">output_spaces</span><span class="o">=</span><span class="p">[</span><span class="n">env</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">name</span><span class="o">=</span><span class="n">ENV_INP_STATE</span><span class="p">,</span>
        <span class="n">choi</span><span class="o">=</span><span class="n">env_inp_state</span>
    <span class="p">)</span>

    <span class="n">ENV_TRACE</span> <span class="o">=</span> <span class="s1">&#39;ENVIRONMENT TRACE&#39;</span>
    <span class="n">env_trace</span> <span class="o">=</span> <span class="n">choi_identity</span><span class="p">([</span><span class="n">env</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">sdict</span><span class="o">=</span><span class="n">sd</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">ENV_TRACE</span><span class="p">)</span>

    <span class="n">CHANNEL</span> <span class="o">=</span> <span class="s1">&#39;CHANNEL&#39;</span>
    <span class="n">ch_comb_ten_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ch_comb_tensors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_ch_comb</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">ch_per_ch_comb</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">ch_per_ch_comb</span>

        <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">CHANNEL</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">ch_comb_tensor</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span>
            <span class="n">inp</span><span class="p">[</span><span class="n">x</span><span class="p">:</span><span class="n">y</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="n">x</span><span class="p">:</span><span class="n">y</span><span class="p">],</span> <span class="n">env</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">env</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">sd</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span>
        <span class="p">)</span>
        <span class="n">ch_comb_ten_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">ch_comb_tensors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ch_comb_tensor</span><span class="p">)</span>
    <span class="n">channels_tnet</span> <span class="o">=</span> <span class="n">TensorNetwork</span><span class="p">(</span><span class="n">ch_comb_tensors</span><span class="p">,</span> <span class="n">sd</span><span class="p">,</span> <span class="n">CHANNEL</span><span class="p">)</span>

    <span class="n">MEASUREMENT</span> <span class="o">=</span> <span class="s1">&#39;MEASUREMENT&#39;</span>
    <span class="n">m_tensor</span> <span class="o">=</span> <span class="n">measure_var</span><span class="p">([</span><span class="n">out</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">anc</span><span class="p">],</span> <span class="n">MEASUREMENT</span><span class="p">,</span> <span class="n">sd</span><span class="p">)</span>

    <span class="n">tn</span> <span class="o">=</span> <span class="n">comb</span> <span class="o">*</span> <span class="n">env_inp_tensor</span> <span class="o">*</span> <span class="n">channels_tnet</span> <span class="o">*</span> <span class="n">env_trace</span> <span class="o">*</span> <span class="n">m_tensor</span>

    <span class="k">if</span> <span class="n">artificial_noise_after</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">noise_spaces</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">elif</span> <span class="n">artificial_noise_after</span><span class="p">:</span>
        <span class="n">noise_spaces</span> <span class="o">=</span> <span class="p">[[</span><span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">noise_spaces</span> <span class="o">=</span> <span class="p">[[</span><span class="n">inp</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

    <span class="n">contraction_order</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">ENV_INP_STATE</span><span class="p">]</span>
    <span class="n">contraction_order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ch_comb_ten_names</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">contraction_order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">COMB</span><span class="p">)</span>
    <span class="n">contraction_order</span> <span class="o">+=</span> <span class="n">ch_comb_ten_names</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">contraction_order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ENV_TRACE</span><span class="p">)</span>
    <span class="n">contraction_order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">MEASUREMENT</span><span class="p">)</span>

    <span class="n">qfi</span><span class="p">,</span> <span class="n">qfiss</span><span class="p">,</span> <span class="n">new_tn</span><span class="p">,</span> <span class="n">status</span> <span class="o">=</span> <span class="n">iss_opt</span><span class="p">(</span>
        <span class="n">tn</span><span class="p">,</span> <span class="n">art_noise_spaces</span><span class="o">=</span><span class="n">noise_spaces</span><span class="p">,</span>
        <span class="n">contraction_order</span><span class="o">=</span><span class="n">contraction_order</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span>

    <span class="n">comb_arr</span> <span class="o">=</span> <span class="n">new_tn</span><span class="o">.</span><span class="n">tensors</span><span class="p">[</span><span class="n">COMB</span><span class="p">]</span><span class="o">.</span><span class="n">choi</span><span class="p">(</span><span class="n">inp</span> <span class="o">+</span> <span class="p">[</span><span class="n">anc</span><span class="p">]</span> <span class="o">+</span> <span class="n">out</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">sld_arr</span> <span class="o">=</span> <span class="n">new_tn</span><span class="o">.</span><span class="n">tensors</span><span class="p">[</span><span class="n">MEASUREMENT</span><span class="p">]</span><span class="o">.</span><span class="n">choi</span><span class="p">([</span><span class="n">out</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">anc</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">qfi</span><span class="p">,</span> <span class="n">qfiss</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">comb_arr</span><span class="p">,</span> <span class="n">sld_arr</span><span class="p">,</span> <span class="n">status</span></div>



<div class="viewcode-block" id="iss_tnet_adaptive_qfi">
<a class="viewcode-back" href="../../../qmetro.protocols.html#qmetro.protocols.iss.iss_tnet_adaptive_qfi">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">iss_tnet_adaptive_qfi</span><span class="p">(</span><span class="n">channel</span> <span class="p">:</span> <span class="n">ParamChannel</span><span class="p">,</span> <span class="n">number_of_channels</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">ancilla_dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">unital_teeth</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">initial_teeth</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">initial_sld</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">artificial_noise_after</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">fixed_teeth</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">env_inp_state</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span>
        <span class="nb">float</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">bool</span>
    <span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes quantum Fisher information in an adaptive control</span>
<span class="sd">    system called quantum comb using iterative see-saw (ISS) algorithm</span>
<span class="sd">    [1]_.</span>

<span class="sd">    In this approach we consider n copies of a quantum channel Phi:</span>
<span class="sd">    </span>
<span class="sd">        Phi_i: L(env_i (x) in_i) -&gt; L(env_i+1 (x) out_i) </span>
<span class="sd">        for i = 0, ..., n - 1,</span>

<span class="sd">    intertwined with n maps called teeth:</span>
<span class="sd">    - input state (or 0-th tooth):</span>
<span class="sd">    </span>
<span class="sd">        T_0: C -&gt; L(in_0 (x) anc_0),</span>
<span class="sd">    </span>
<span class="sd">    - (proper) teeth:</span>
<span class="sd">    </span>
<span class="sd">        T_i: L(out_i-1 (x) anc_i-1) -&gt; L(in_i (x) anc_i)</span>
<span class="sd">        for i = 1, ..., n - 1,</span>

<span class="sd">    which constitute an adaptive control system called quantum comb and a</span>
<span class="sd">    measurement at the end:</span>

<span class="sd">        P: L(out_n-1 (x) anc_n-1) -&gt; R.</span>

<span class="sd">    The input of the first environment space (env_0) is initialized with</span>
<span class="sd">    `env_inp_state` and the last environment spcace (env_n) is traced out.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    channel : ParamChannel</span>
<span class="sd">        Channel to compute quantum Fisher information for. In case this</span>
<span class="sd">        argument is a comb created from single channels the control</span>
<span class="sd">        operation (tooth) will be put between every **single** channel.</span>
<span class="sd">    number_of_channels : int</span>
<span class="sd">        Number of channel uses. In case `channel` is a comb created from</span>
<span class="sd">        `m` single channels the total number of channels will be equal to</span>
<span class="sd">        `number_of_channels * m`.</span>
<span class="sd">    ancilla_dim : int</span>
<span class="sd">        Dimension of the ancilla space connecting controls (teeth),</span>
<span class="sd">        dim(anc_i).</span>
<span class="sd">    unital_teeth : bool, optional</span>
<span class="sd">        If True than all proper teeth (T_i with i&gt;0) are constrained to be</span>
<span class="sd">        unital, that is they preserve identity matrix T_i(Id) = Id, by</span>
<span class="sd">        default False.</span>
<span class="sd">    initial_teeth : list[np.ndarray] | None, optional</span>
<span class="sd">        Initial values of teeth: [T_0, T_1, ...]. First element that is</span>
<span class="sd">        the value for the input state should be its density matrix with</span>
<span class="sd">        spaces in the order: (inp_0, anc_0). For proper teeth it should be</span>
<span class="sd">        Choi matrices with spaces in the order: (inp_i, anc_i, out_i-1,</span>
<span class="sd">        anc_i-1), by default None.</span>
<span class="sd">    initial_sld : np.ndarray | None, optional</span>
<span class="sd">        Initial value of SLD matrix with spaces in order (out_n-1,</span>
<span class="sd">        anc_n-1), by default None.</span>
<span class="sd">    artificial_noise_after : bool, optional</span>
<span class="sd">        Whether auxiliary noise is added after the channel:</span>
<span class="sd">        - True : auxiliary noise is added after the channel,</span>
<span class="sd">        - False : auxiliary noise is added before the channel,</span>
<span class="sd">        - None : auxiliary noise is not used.</span>
<span class="sd">        By default True.</span>
<span class="sd">    fixed_teeth : list[tuple[int, np.ndarray]] | None, optional</span>
<span class="sd">        Teeths to be fixed during optimization. Element (i, Ti) in the</span>
<span class="sd">        list means that tooth number i will be fixed to Ti. Note that this</span>
<span class="sd">        value will replace the value given in initial_teeth argument, by</span>
<span class="sd">        default None.</span>
<span class="sd">    env_inp_state : np.ndarray | None, optional</span>
<span class="sd">        Density matrix of the initial state of the environment. If None</span>
<span class="sd">        then it becomes a maximally mixed state.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    qfi : float</span>
<span class="sd">        Quantum Fisher information.</span>
<span class="sd">    qfis : list[floats]</span>
<span class="sd">        A list of quantum Fisher informations acvhieved in each iteration.</span>
<span class="sd">        The last value in the list is the final solution.</span>
<span class="sd">    Ts : list[np.ndarray]</span>
<span class="sd">        List of optimal teeth in the form of density matrix and Choi</span>
<span class="sd">        matrices. For the i-th element - T_i spaces are in order:</span>
<span class="sd">        - (inp_0, anc_0) for i=0,</span>
<span class="sd">        - (inp_i, anc_i, out_i-1, anc_i-1) for i&gt;0.</span>
<span class="sd">    L : np.ndarray</span>
<span class="sd">        Optimal syymetric logaritmic derivative (SLD) matrix with spaces</span>
<span class="sd">        in order: out_n-1, anc.</span>
<span class="sd">    status : bool</span>
<span class="sd">        True if the algorithm converged, False otherwise.</span>

<span class="sd">    References</span>
<span class="sd">    -------</span>
<span class="sd">    .. [1] S. Kurdzia≈Çek et al. Quantum metrology using quantum combs and</span>
<span class="sd">           tensor network formalism, New Journal of Physics (2024).</span>
<span class="sd">           https://doi.org/10.1088/1367-2630/ada8d1</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">channel</span><span class="o">.</span><span class="n">env_inp_dim</span> <span class="o">!=</span> <span class="n">channel</span><span class="o">.</span><span class="n">env_out_dim</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">number_of_channels</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">channel</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">trace_env</span><span class="p">(</span><span class="n">env_inp_state</span><span class="p">)</span>
            <span class="c1"># To avoid error for env_inp_tensor declaration:</span>
            <span class="n">env_inp_state</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">EnvDimsError</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">env_inp_dim</span><span class="p">,</span> <span class="n">channel</span><span class="o">.</span><span class="n">env_out_dim</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">unital_teeth</span> <span class="ow">and</span> <span class="n">channel</span><span class="o">.</span><span class="n">input_dims</span> <span class="o">!=</span> <span class="n">channel</span><span class="o">.</span><span class="n">output_dims</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">UnitalDimsError</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">input_dims</span><span class="p">,</span> <span class="n">channel</span><span class="o">.</span><span class="n">output_dims</span><span class="p">)</span>

    <span class="n">env_dim</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">env_inp_dim</span>

    <span class="c1"># ch_comb for number &quot;channel combs&quot; i.e. combs of channels to</span>
    <span class="c1"># differentiate from comb of controls.</span>
    <span class="n">n_ch_comb</span> <span class="o">=</span> <span class="n">number_of_channels</span>
    <span class="n">ch_per_ch_comb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">input_spaces</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">n_ch_comb</span> <span class="o">*</span> <span class="n">ch_per_ch_comb</span>

    <span class="n">sd</span> <span class="o">=</span> <span class="n">SpaceDict</span><span class="p">()</span>
    <span class="n">inp</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;IN&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;OUT&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">space</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">cycle</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">input_dims</span><span class="p">)):</span>
        <span class="n">sd</span><span class="p">[</span><span class="n">space</span><span class="p">]</span> <span class="o">=</span> <span class="n">dim</span>
    <span class="k">for</span> <span class="n">space</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">cycle</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">output_dims</span><span class="p">)):</span>
        <span class="n">sd</span><span class="p">[</span><span class="n">space</span><span class="p">]</span> <span class="o">=</span> <span class="n">dim</span>
    <span class="n">anc</span> <span class="o">=</span> <span class="n">sd</span><span class="o">.</span><span class="n">arrange_spaces</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">ancilla_dim</span><span class="p">,</span> <span class="s1">&#39;ANC&#39;</span><span class="p">)</span>
    <span class="n">env</span> <span class="o">=</span> <span class="n">sd</span><span class="o">.</span><span class="n">arrange_spaces</span><span class="p">(</span><span class="n">n_ch_comb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">env_dim</span><span class="p">,</span> <span class="s1">&#39;ENV&#39;</span><span class="p">)</span>

    <span class="n">fixed_teeth_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">fixed_teeth</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">fixed_teeth</span><span class="p">:</span>
            <span class="n">fixed_teeth_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span>

    <span class="n">COMB</span> <span class="o">=</span> <span class="s1">&#39;COMB&#39;</span>
    <span class="n">teeth</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">teeth_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">tooth_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">COMB</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">teeth_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tooth_name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">tooth_inp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tooth_inp</span> <span class="o">=</span> <span class="p">[</span><span class="n">out</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">anc</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]]</span>

        <span class="n">tooth_out</span> <span class="o">=</span> <span class="p">[</span><span class="n">inp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">anc</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>

        <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fixed_teeth_dict</span><span class="p">:</span>
            <span class="n">tooth_tensor</span> <span class="o">=</span> <span class="n">VarTensor</span><span class="p">(</span>
                <span class="n">tooth_out</span> <span class="o">+</span> <span class="n">tooth_inp</span><span class="p">,</span> <span class="n">sd</span><span class="p">,</span> <span class="n">tooth_name</span><span class="p">,</span> <span class="n">tooth_out</span><span class="p">,</span>
                <span class="n">unital_teeth</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tooth_tensor</span> <span class="o">=</span> <span class="n">ConstTensor</span><span class="p">(</span>
                <span class="n">tooth_out</span> <span class="o">+</span> <span class="n">tooth_inp</span><span class="p">,</span> <span class="n">sdict</span><span class="o">=</span><span class="n">sd</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">tooth_name</span><span class="p">,</span>
                <span class="n">output_spaces</span><span class="o">=</span><span class="n">tooth_out</span><span class="p">,</span> <span class="n">choi</span><span class="o">=</span><span class="n">fixed_teeth_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="n">teeth</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tooth_tensor</span><span class="p">)</span>

    <span class="n">comb</span> <span class="o">=</span> <span class="n">TensorNetwork</span><span class="p">(</span><span class="n">teeth</span><span class="p">,</span> <span class="n">sd</span><span class="p">,</span> <span class="n">COMB</span><span class="p">)</span>

    <span class="n">ENV_INP_STATE</span> <span class="o">=</span> <span class="s1">&#39;ENVIRONMENT INPUT STATE&#39;</span>
    <span class="k">if</span> <span class="n">env_inp_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">env_inp_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">env_dim</span><span class="p">)</span> <span class="o">/</span> <span class="n">env_dim</span>
    <span class="n">env_inp_tensor</span> <span class="o">=</span> <span class="n">ConstTensor</span><span class="p">(</span>
        <span class="p">[</span><span class="n">env</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">sdict</span><span class="o">=</span><span class="n">sd</span><span class="p">,</span> <span class="n">output_spaces</span><span class="o">=</span><span class="p">[</span><span class="n">env</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">name</span><span class="o">=</span><span class="n">ENV_INP_STATE</span><span class="p">,</span>
        <span class="n">choi</span><span class="o">=</span><span class="n">env_inp_state</span>
    <span class="p">)</span>

    <span class="n">ENV_TRACE</span> <span class="o">=</span> <span class="s1">&#39;ENVIRONMENT TRACE&#39;</span>
    <span class="n">env_trace</span> <span class="o">=</span> <span class="n">choi_identity</span><span class="p">([</span><span class="n">env</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">sdict</span><span class="o">=</span><span class="n">sd</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">ENV_TRACE</span><span class="p">)</span>

    <span class="n">CHANNEL</span> <span class="o">=</span> <span class="s1">&#39;CHANNEL&#39;</span>
    <span class="n">ch_comb_ten_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ch_comb_tensors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_ch_comb</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">ch_per_ch_comb</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">ch_per_ch_comb</span>

        <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">CHANNEL</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">ch_comb_tensor</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span>
            <span class="n">inp</span><span class="p">[</span><span class="n">x</span><span class="p">:</span><span class="n">y</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="n">x</span><span class="p">:</span><span class="n">y</span><span class="p">],</span> <span class="n">env</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">env</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">sd</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span>
        <span class="p">)</span>
        <span class="n">ch_comb_ten_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">ch_comb_tensors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ch_comb_tensor</span><span class="p">)</span>
    <span class="n">channels_tnet</span> <span class="o">=</span> <span class="n">TensorNetwork</span><span class="p">(</span><span class="n">ch_comb_tensors</span><span class="p">,</span> <span class="n">sd</span><span class="p">,</span> <span class="n">CHANNEL</span><span class="p">)</span>

    <span class="n">MEASUREMENT</span> <span class="o">=</span> <span class="s1">&#39;MEASUREMENT&#39;</span>
    <span class="n">m_tensor</span> <span class="o">=</span> <span class="n">measure_var</span><span class="p">([</span><span class="n">out</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">anc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">MEASUREMENT</span><span class="p">,</span> <span class="n">sd</span><span class="p">)</span>

    <span class="n">tn</span> <span class="o">=</span> <span class="n">comb</span> <span class="o">*</span> <span class="n">env_inp_tensor</span> <span class="o">*</span> <span class="n">channels_tnet</span> <span class="o">*</span> <span class="n">env_trace</span> <span class="o">*</span> <span class="n">m_tensor</span>

    <span class="n">init_tensors</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">initial_teeth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">init_tooth</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">initial_teeth</span><span class="p">):</span>
            <span class="n">spaces</span> <span class="o">=</span> <span class="p">[</span><span class="n">inp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">anc</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">spaces</span> <span class="o">+=</span> <span class="p">[</span><span class="n">out</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">anc</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]]</span>

            <span class="n">_ct</span> <span class="o">=</span> <span class="n">ConstTensor</span><span class="p">(</span>
                <span class="n">spaces</span><span class="p">,</span> <span class="n">choi</span><span class="o">=</span><span class="n">init_tooth</span><span class="p">,</span> <span class="n">sdict</span><span class="o">=</span><span class="n">sd</span><span class="p">,</span>
                <span class="n">output_spaces</span><span class="o">=</span><span class="p">[</span><span class="n">inp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">anc</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">name</span><span class="o">=</span><span class="n">teeth_names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">init_tensors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_ct</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">initial_sld</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">ConstTensor</span><span class="p">(</span>
            <span class="p">[</span><span class="n">out</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">anc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">initial_sld</span><span class="p">,</span> <span class="n">sd</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">MEASUREMENT</span>
        <span class="p">)</span>
        <span class="n">init_tensors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">init_tn</span> <span class="o">=</span> <span class="n">TensorNetwork</span><span class="p">(</span><span class="n">init_tensors</span><span class="p">,</span> <span class="n">sd</span><span class="p">)</span> <span class="k">if</span> <span class="n">init_tensors</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">artificial_noise_after</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">noise_spaces</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">elif</span> <span class="n">artificial_noise_after</span><span class="p">:</span>
        <span class="n">noise_spaces</span> <span class="o">=</span> <span class="p">[[</span><span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">noise_spaces</span> <span class="o">=</span> <span class="p">[[</span><span class="n">inp</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

    <span class="n">contraction_order</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">contraction_order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">teeth_names</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">contraction_order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ENV_INP_STATE</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="n">ch_per_ch_comb</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span> <span class="o">/</span> <span class="n">ch_per_ch_comb</span><span class="p">)</span>
            <span class="n">contraction_order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ch_comb_ten_names</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
    <span class="n">contraction_order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ENV_TRACE</span><span class="p">)</span>
    <span class="n">contraction_order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">MEASUREMENT</span><span class="p">)</span>

    <span class="n">qfi</span><span class="p">,</span> <span class="n">qfiss</span><span class="p">,</span> <span class="n">new_tn</span><span class="p">,</span> <span class="n">status</span> <span class="o">=</span> <span class="n">iss_opt</span><span class="p">(</span>
        <span class="n">tn</span><span class="p">,</span> <span class="n">init_tn</span><span class="o">=</span><span class="n">init_tn</span><span class="p">,</span> <span class="n">art_noise_spaces</span><span class="o">=</span><span class="n">noise_spaces</span><span class="p">,</span>
        <span class="n">contraction_order</span><span class="o">=</span><span class="n">contraction_order</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span>

    <span class="n">teeth_arrs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">new_tn</span><span class="o">.</span><span class="n">tensors</span><span class="p">[</span><span class="n">teeth_names</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>

        <span class="n">spaces</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">inp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">anc</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">spaces</span> <span class="o">+=</span> <span class="p">[</span><span class="n">out</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">anc</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]]</span>

        <span class="n">t_arr</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">choi</span><span class="p">(</span><span class="n">spaces</span><span class="p">)</span>
        <span class="n">teeth_arrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t_arr</span><span class="p">)</span>

    <span class="n">sld_arr</span> <span class="o">=</span> <span class="n">new_tn</span><span class="o">.</span><span class="n">tensors</span><span class="p">[</span><span class="n">MEASUREMENT</span><span class="p">]</span><span class="o">.</span><span class="n">choi</span><span class="p">([</span><span class="n">out</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">anc</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]])</span>

    <span class="k">return</span> <span class="n">qfi</span><span class="p">,</span> <span class="n">qfiss</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">teeth_arrs</span><span class="p">,</span> <span class="n">sld_arr</span><span class="p">,</span> <span class="n">status</span></div>



<div class="viewcode-block" id="iss_tnet_collisional_qfi">
<a class="viewcode-back" href="../../../qmetro.protocols.html#qmetro.protocols.iss.iss_tnet_collisional_qfi">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">iss_tnet_collisional_qfi</span><span class="p">(</span><span class="n">channel</span><span class="p">:</span> <span class="n">ParamChannel</span><span class="p">,</span>
    <span class="n">number_of_channels</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">ancilla_dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">mps_bond_dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">measure_bond_dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">unital_teeth</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">initial_teeth</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">artificial_noise_after</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">fixed_teeth</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">env_inp_state</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span>
        <span class="nb">float</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="nb">bool</span>
    <span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the quantum Fisher information in a scenario with channels in</span>
<span class="sd">    a comb which teeth have separate ancillas using iterative see-saw</span>
<span class="sd">    (ISS) algorithm. This is a very similar structure to the one in the</span>
<span class="sd">    adaptive strategy the only difference being that comb&#39;s teeth cannot</span>
<span class="sd">    communicate with each other using their common ancilla space.</span>

<span class="sd">    More precisely, in this approach we consider n copies of a quantum</span>
<span class="sd">    channel Phi:</span>
<span class="sd">    </span>
<span class="sd">        Phi_i: L(env_i (x) in_i) -&gt; L(env_i+1 (x) out_i) </span>
<span class="sd">        for i = 0, ..., n - 1,</span>

<span class="sd">    an input state:</span>

<span class="sd">        rho0 in L(in_0 (x) anc_0 (x) ... (x) anc_n-2),</span>
<span class="sd">    </span>
<span class="sd">    controls called also teeth:</span>
<span class="sd">        </span>
<span class="sd">        T_i: L(out_i-1 (x) anc_i-1) -&gt; L(in_i (x) anc&#39;_i-1)</span>
<span class="sd">        for i = 1, ..., n - 1,</span>

<span class="sd">    and measurement at the end:</span>

<span class="sd">        P: L(anc&#39;_0 (x) ... (x) anc&#39;_n-2 (x) out_n-1) -&gt; R.</span>

<span class="sd">    The input of the first environment space (env_0) is initialized with</span>
<span class="sd">    `env_inp_state` and the last environment spcace (env_n) is traced out.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    channel : ParamChannel</span>
<span class="sd">        Channel to compute quantum Fisher information for. In case this</span>
<span class="sd">        argument is a comb created from single channels the control</span>
<span class="sd">        operation (comb&#39;s tooth) will be put between every **single**</span>
<span class="sd">        channel.</span>
<span class="sd">    number_of_channels : int</span>
<span class="sd">        Number of channel uses. In case `channel` is a comb created from</span>
<span class="sd">        `m` single channels the total number of channels will be equal to</span>
<span class="sd">        `number_of_channels * m`.</span>
<span class="sd">    ancilla_dim : int</span>
<span class="sd">        Dimension of the ancilla space connecting controls (teeth).</span>
<span class="sd">    mps_bond_dim : int</span>
<span class="sd">        Dimension of the bond space of the input state which is a matrix</span>
<span class="sd">        product state.</span>
<span class="sd">    measure_bond_dim : int</span>
<span class="sd">        Dimension of the bond space of the measurement (SLD matrix) which</span>
<span class="sd">        is a matrix product operator.</span>
<span class="sd">    unital_teeth : bool, optional</span>
<span class="sd">        If True than all proper teeth (T_i with i&gt;0) are constrained to be</span>
<span class="sd">        unital, that is they preserve identity matrix T_i(Id) = Id, by</span>
<span class="sd">        default False.</span>
<span class="sd">    initial_teeth : list[np.ndarray] | None, optional</span>
<span class="sd">        Initial values of teeth: [T_1, ...]. For T_i it should be its</span>
<span class="sd">        Choi matrix with spaces in the order: (inp_i, anc&#39;_i-1, out_i-1,</span>
<span class="sd">        anc_i-1), by default None.</span>
<span class="sd">    artificial_noise_after : bool, optional</span>
<span class="sd">        Whether auxiliary noise is added after the channel:</span>
<span class="sd">        - True : auxiliary noise is added after the channel,</span>
<span class="sd">        - False : auxiliary noise is added before the channel,</span>
<span class="sd">        - None : auxiliary noise is not used.</span>
<span class="sd">        By default True.</span>
<span class="sd">    fixed_teeth : list[tuple[int, np.ndarray]] | None, optional</span>
<span class="sd">        Teeths to be fixed during optimization. Element (i, Ti) in the</span>
<span class="sd">        list means that tooth number i will be fixed to Ti. Note that this</span>
<span class="sd">        value will replace the value given in initial_teeth argument, by</span>
<span class="sd">        default None.</span>
<span class="sd">    env_inp_state : np.ndarray | None, optional</span>
<span class="sd">        Density matrix of the initial state of the environment. If None</span>
<span class="sd">        then it becomes a maximally mixed state.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    qfi : float</span>
<span class="sd">        Quantum Fisher information.</span>
<span class="sd">    qfis : list[floats]</span>
<span class="sd">        A list of quantum Fisher informations computed in each iteration.</span>
<span class="sd">        The last value in the list is the final solution.</span>
<span class="sd">    input_state : list[np.array]</span>
<span class="sd">        The optimal matrix product state (MPS). The i-th tensor on the list</span>
<span class="sd">        - R_i is the input of the i-th channel except the last which is the</span>
<span class="sd">        part going to ancilla. Its indices are in the order: bond space</span>
<span class="sd">        connecting to the previous tensor (if it exists), input state of</span>
<span class="sd">        the channel/ancilla, bond space connecting to the next tensor (if</span>
<span class="sd">        it exists).</span>
<span class="sd">    Ts : list[np.ndarray]</span>
<span class="sd">        List of optimal teeth [T_1, T_2, ...] in the form of their Choi</span>
<span class="sd">        matrices. For the i-th element - T_i spaces are in order (inp_i,</span>
<span class="sd">        anc&#39;_i-1, out_i-1, anc_i-1).</span>
<span class="sd">    sld : list[np.array]</span>
<span class="sd">        Matrix product operator (MPO) of the optimal symmetric logarithmic</span>
<span class="sd">        derivative (SLD). For i &lt; n-1 i-th tensor on the list is a sld</span>
<span class="sd">        element on anc&#39;_i then the last tensor on the list is a sld</span>
<span class="sd">        element on space out_n-1. Indices/spaces of the i-th tnesor are in</span>
<span class="sd">        the order: bond space connecting to the previous tensor (if it</span>
<span class="sd">        exists), out_n-1 or anc&#39;_i-1, bond space connecting to the next</span>
<span class="sd">        tensor (if it exists).</span>
<span class="sd">    status : bool</span>
<span class="sd">        True if the algorithm converged, False otherwise.</span>
<span class="sd">    </span>
<span class="sd">    References</span>
<span class="sd">    -------</span>
<span class="sd">    .. [1] K. Chabuda et al. Tensor-Network Approach for Quantum Metrology</span>
<span class="sd">           in Many-Body Quantum Systems, Nature Commun 11, 250 (2020).</span>
<span class="sd">           https://doi.org/10.1038/s41467-019-13735-9</span>
<span class="sd">    .. [2] S. Kurdzia≈Çek et al. Quantum metrology using quantum combs and</span>
<span class="sd">           tensor network formalism, New Journal of Physics (2024).</span>
<span class="sd">           https://doi.org/10.1088/1367-2630/ada8d1</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">channel</span><span class="o">.</span><span class="n">env_inp_dim</span> <span class="o">!=</span> <span class="n">channel</span><span class="o">.</span><span class="n">env_out_dim</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">number_of_channels</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">channel</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">trace_env</span><span class="p">(</span><span class="n">env_inp_state</span><span class="p">)</span>
            <span class="c1"># To avoid error for later env_inp_tensor declaration:</span>
            <span class="n">env_inp_state</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">EnvDimsError</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">env_inp_dim</span><span class="p">,</span> <span class="n">channel</span><span class="o">.</span><span class="n">env_out_dim</span><span class="p">)</span>
    <span class="n">env_dim</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">env_inp_dim</span>

    <span class="k">if</span> <span class="n">unital_teeth</span> <span class="ow">and</span> <span class="n">channel</span><span class="o">.</span><span class="n">input_dims</span> <span class="o">!=</span> <span class="n">channel</span><span class="o">.</span><span class="n">output_dims</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">UnitalDimsError</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">input_dims</span><span class="p">,</span> <span class="n">channel</span><span class="o">.</span><span class="n">output_dims</span><span class="p">)</span>

    <span class="c1"># ch_comb for number &quot;channel combs&quot; i.e. combs of channels to</span>
    <span class="c1"># differentiate from comb of controls.</span>
    <span class="n">n_ch_comb</span> <span class="o">=</span> <span class="n">number_of_channels</span>
    <span class="n">ch_per_ch_comb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">input_spaces</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">n_ch_comb</span> <span class="o">*</span> <span class="n">ch_per_ch_comb</span>

    <span class="n">sd</span> <span class="o">=</span> <span class="n">SpaceDict</span><span class="p">()</span>
    <span class="n">inp</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;IN&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;OUT&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">space</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">cycle</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">input_dims</span><span class="p">)):</span>
        <span class="n">sd</span><span class="p">[</span><span class="n">space</span><span class="p">]</span> <span class="o">=</span> <span class="n">dim</span>
    <span class="k">for</span> <span class="n">space</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">cycle</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">output_dims</span><span class="p">)):</span>
        <span class="n">sd</span><span class="p">[</span><span class="n">space</span><span class="p">]</span> <span class="o">=</span> <span class="n">dim</span>
    <span class="n">anc_pre</span> <span class="o">=</span> <span class="n">sd</span><span class="o">.</span><span class="n">arrange_spaces</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ancilla_dim</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;ANC&#39;</span><span class="p">,</span> <span class="s1">&#39;PRE&#39;</span><span class="p">))</span>
    <span class="n">anc_post</span> <span class="o">=</span> <span class="n">sd</span><span class="o">.</span><span class="n">arrange_spaces</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ancilla_dim</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;ANC&#39;</span><span class="p">,</span> <span class="s1">&#39;POST&#39;</span><span class="p">))</span>
    <span class="n">env</span> <span class="o">=</span> <span class="n">sd</span><span class="o">.</span><span class="n">arrange_spaces</span><span class="p">(</span><span class="n">n_ch_comb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">env_dim</span><span class="p">,</span> <span class="s1">&#39;ENV&#39;</span><span class="p">)</span>

    <span class="n">RHO0</span> <span class="o">=</span> <span class="s1">&#39;RHO0&#39;</span>
    <span class="n">mps</span><span class="p">,</span> <span class="n">mps_names</span><span class="p">,</span> <span class="n">mps_bonds</span> <span class="o">=</span> <span class="n">mps_var_tnet</span><span class="p">(</span>
        <span class="p">[</span><span class="n">inp</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="n">anc_pre</span><span class="p">,</span> <span class="n">RHO0</span><span class="p">,</span> <span class="n">sd</span><span class="p">,</span> <span class="n">mps_bond_dim</span>
    <span class="p">)</span>

    <span class="n">fixed_teeth_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">fixed_teeth</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">fixed_teeth</span><span class="p">:</span>
            <span class="n">fixed_teeth_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span>

    <span class="n">TOOTH</span> <span class="o">=</span> <span class="s1">&#39;TOOTH&#39;</span>
    <span class="n">teeth</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">teeth_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">tooth_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">TOOTH</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">teeth_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tooth_name</span><span class="p">)</span>
        <span class="n">tooth_inp</span> <span class="o">=</span> <span class="p">[</span><span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">anc_pre</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="n">tooth_out</span> <span class="o">=</span> <span class="p">[</span><span class="n">inp</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">anc_post</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>

        <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">fixed_teeth_dict</span><span class="p">:</span>
            <span class="n">tooth</span> <span class="o">=</span> <span class="n">ConstTensor</span><span class="p">(</span>
                <span class="n">tooth_out</span> <span class="o">+</span> <span class="n">tooth_inp</span><span class="p">,</span> <span class="n">sdict</span><span class="o">=</span><span class="n">sd</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">tooth_name</span><span class="p">,</span>
                <span class="n">output_spaces</span><span class="o">=</span><span class="n">tooth_out</span><span class="p">,</span> <span class="n">choi</span><span class="o">=</span><span class="n">fixed_teeth_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tooth</span> <span class="o">=</span> <span class="n">VarTensor</span><span class="p">(</span>
                <span class="n">tooth_out</span> <span class="o">+</span> <span class="n">tooth_inp</span><span class="p">,</span> <span class="n">sdict</span><span class="o">=</span><span class="n">sd</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">tooth_name</span><span class="p">,</span>
                <span class="n">output_spaces</span><span class="o">=</span><span class="n">tooth_out</span><span class="p">,</span> <span class="n">is_unital</span><span class="o">=</span><span class="n">unital_teeth</span>
            <span class="p">)</span>
        <span class="n">teeth</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tooth</span><span class="p">)</span>

    <span class="n">ENV_INP_STATE</span> <span class="o">=</span> <span class="s1">&#39;ENVIRONMENT INPUT STATE&#39;</span>
    <span class="k">if</span> <span class="n">env_inp_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">env_inp_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">env_dim</span><span class="p">)</span> <span class="o">/</span> <span class="n">env_dim</span>
    <span class="n">env_inp_tensor</span> <span class="o">=</span> <span class="n">ConstTensor</span><span class="p">(</span>
        <span class="p">[</span><span class="n">env</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">sdict</span><span class="o">=</span><span class="n">sd</span><span class="p">,</span> <span class="n">output_spaces</span><span class="o">=</span><span class="p">[</span><span class="n">env</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">name</span><span class="o">=</span><span class="n">ENV_INP_STATE</span><span class="p">,</span>
        <span class="n">choi</span><span class="o">=</span><span class="n">env_inp_state</span>
    <span class="p">)</span>

    <span class="n">ENV_TRACE</span> <span class="o">=</span> <span class="s1">&#39;ENVIRONMENT TRACE&#39;</span>
    <span class="n">env_trace</span> <span class="o">=</span> <span class="n">choi_identity</span><span class="p">([</span><span class="n">env</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">sdict</span><span class="o">=</span><span class="n">sd</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">ENV_TRACE</span><span class="p">)</span>

    <span class="n">CHANNEL</span> <span class="o">=</span> <span class="s1">&#39;CHANNEL&#39;</span>
    <span class="n">ch_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">chans</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_ch_comb</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">ch_per_ch_comb</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">ch_per_ch_comb</span>

        <span class="n">channel_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">CHANNEL</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">chan</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span>
            <span class="n">inp</span><span class="p">[</span><span class="n">x</span><span class="p">:</span><span class="n">y</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="n">x</span><span class="p">:</span><span class="n">y</span><span class="p">],</span> <span class="n">env</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">env</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">sd</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">channel_name</span>
        <span class="p">)</span>

        <span class="n">ch_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">channel_name</span><span class="p">)</span>
        <span class="n">chans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chan</span><span class="p">)</span>
    <span class="n">channels</span> <span class="o">=</span> <span class="n">TensorNetwork</span><span class="p">(</span><span class="n">chans</span><span class="p">,</span> <span class="n">sd</span><span class="p">,</span> <span class="n">CHANNEL</span><span class="p">)</span>

    <span class="n">MEASUREMENT</span> <span class="o">=</span> <span class="s1">&#39;MEASUREMENT&#39;</span>
    <span class="n">meas_mpo</span><span class="p">,</span> <span class="n">meas_names</span><span class="p">,</span> <span class="n">meas_bonds</span> <span class="o">=</span> <span class="n">mpo_measure_var_tnet</span><span class="p">(</span>
        <span class="n">anc_post</span> <span class="o">+</span> <span class="p">[</span><span class="n">out</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">MEASUREMENT</span><span class="p">,</span> <span class="n">sd</span><span class="p">,</span> <span class="n">measure_bond_dim</span>
    <span class="p">)</span>

    <span class="n">tn</span> <span class="o">=</span> <span class="n">TensorNetwork</span><span class="p">(</span>
        <span class="p">[</span><span class="n">mps</span><span class="p">,</span> <span class="o">*</span><span class="n">teeth</span><span class="p">,</span> <span class="n">env_inp_tensor</span><span class="p">,</span> <span class="n">channels</span><span class="p">,</span> <span class="n">env_trace</span><span class="p">,</span> <span class="n">meas_mpo</span><span class="p">],</span> <span class="n">sd</span>
    <span class="p">)</span>

    <span class="n">init_teeth</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">initial_teeth</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t_arr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">initial_teeth</span><span class="p">):</span>
            <span class="n">_c</span> <span class="o">=</span> <span class="n">ConstTensor</span><span class="p">(</span>
                <span class="p">[</span><span class="n">inp</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">anc_post</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">anc_pre</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">sdict</span><span class="o">=</span><span class="n">sd</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="n">teeth_names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">choi</span><span class="o">=</span><span class="n">t_arr</span><span class="p">,</span>
                <span class="n">output_spaces</span><span class="o">=</span><span class="p">[</span><span class="n">inp</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">anc_post</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="p">)</span>
            <span class="n">init_teeth</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_c</span><span class="p">)</span>
    <span class="c1"># TODO: Add initial input state and initial sld.</span>
    <span class="n">init_tn</span> <span class="o">=</span> <span class="n">TensorNetwork</span><span class="p">(</span><span class="n">init_teeth</span><span class="p">,</span> <span class="n">sd</span><span class="p">)</span> <span class="k">if</span> <span class="n">init_teeth</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">artificial_noise_after</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">noise_spaces</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">elif</span> <span class="n">artificial_noise_after</span><span class="p">:</span>
        <span class="n">noise_spaces</span> <span class="o">=</span> <span class="p">[[</span><span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">noise_spaces</span> <span class="o">=</span> <span class="p">[[</span><span class="n">inp</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

    <span class="n">contraction_order</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">contraction_order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mps_names</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">contraction_order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ENV_INP_STATE</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="n">ch_per_ch_comb</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span> <span class="o">/</span> <span class="n">ch_per_ch_comb</span><span class="p">)</span>
            <span class="n">contraction_order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ch_names</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">contraction_order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">teeth_names</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">contraction_order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">meas_names</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">contraction_order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ENV_TRACE</span><span class="p">)</span>

    <span class="n">qfi</span><span class="p">,</span> <span class="n">qfiss</span><span class="p">,</span> <span class="n">new_tn</span><span class="p">,</span> <span class="n">status</span> <span class="o">=</span> <span class="n">iss_opt</span><span class="p">(</span>
        <span class="n">tn</span><span class="p">,</span> <span class="n">init_tn</span><span class="o">=</span><span class="n">init_tn</span><span class="p">,</span> <span class="n">art_noise_spaces</span><span class="o">=</span><span class="n">noise_spaces</span><span class="p">,</span>
        <span class="n">contraction_order</span><span class="o">=</span><span class="n">contraction_order</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span>

    <span class="n">mps_arrs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">sld_arrs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">mps_el</span> <span class="o">=</span> <span class="n">new_tn</span><span class="o">.</span><span class="n">tensors</span><span class="p">[</span><span class="n">mps_names</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="n">sld_el</span> <span class="o">=</span> <span class="n">new_tn</span><span class="o">.</span><span class="n">tensors</span><span class="p">[</span><span class="n">meas_names</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="n">mps_spaces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sld_spaces</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mps_spaces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mps_spaces</span> <span class="o">+=</span> <span class="p">[</span><span class="n">mps_bonds</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">anc_pre</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]]</span>
            <span class="n">sld_spaces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">meas_bonds</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">mps_spaces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mps_bonds</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">sld_spaces</span> <span class="o">+=</span> <span class="p">[</span><span class="n">anc_post</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">meas_bonds</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sld_spaces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">mps_arrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mps_el</span><span class="o">.</span><span class="n">to_mps</span><span class="p">(</span><span class="n">mps_spaces</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">sld_el</span><span class="o">.</span><span class="n">reorder</span><span class="p">(</span><span class="n">sld_spaces</span><span class="p">)</span>
        <span class="n">sld_arrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sld_el</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>

    <span class="n">teeth_arrs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">new_tn</span><span class="o">.</span><span class="n">tensors</span><span class="p">[</span><span class="n">teeth_names</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="n">t_arr</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">choi</span><span class="p">([</span><span class="n">inp</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">anc_post</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">anc_pre</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
        <span class="n">teeth_arrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t_arr</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">qfi</span><span class="p">,</span> <span class="n">qfiss</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mps_arrs</span><span class="p">,</span> <span class="n">teeth_arrs</span><span class="p">,</span> <span class="n">sld_arrs</span><span class="p">,</span> <span class="n">status</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Piotr Dulian.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>